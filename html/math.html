<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>자료실</title>
    <link rel = "stylesheet" href = "../css/common.css">
    <link rel = "stylesheet" href = "../css/math.css">
    <!--수식을 위한 부분 참고: https://m.blog.naver.com/mathesis_time/222108156490-->
    <head>
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
        </script>
        <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
    </head>
</head>
<body>
    <section class="layout">
        <div class="sidebar"></div>
        <div class = "header"></div>
        <div class="body">
            <div class = "rights">개인 공부용이며, 복사, 배포를 금지합니다. <br>
                검색은 ctrl + f를 사용하여 원하는 키워드를 입력한 후 찾으면됩니다. <br>
                만약 내용상 오류가 있어 수정을 원한다면 게시판에 문의부탁드립니다. (구현 예정)
            </div>    
            <h1>게임 수학 정리</h1>
            <div class = "info">
                이득우의 게임 수학(이득우 지음)을 정리한 내용입니다. 
            </div>
            <div class = "content2">
                <h3>명제와 공리(axiom)</h3>
                <p>
                    · 명제란 '참'과 '거짓'으로 구분할 수 있는 '객관적 사태'가 포함된 문장이다. <br>
                    · 공리란 명제 중에서도 증명할 필요가 없는 명백한 기본 명제를 말한다. (예를 들어, 1 + 1 = 2는 너무나 명백하여 증명할 필요가 없다. )<br>
                </p>
            </div>
            <div class = "content2">
                <h3>이항 연산(binary operation)</h3>
                <p>
                    · 두 개의 항을 필요로하는 연산자이다. 예를 들어, 사칙 연산이 있다. <br>
                    · 두 개의 원소를 사용하여 새로운 원소를 만들어낸다.  
                </p>
                <h5 id = "binary-operation">이항 연산의 성질</h5>
                <table class = "math-binary-operation">
                    <tr>
                        <th>성질</th>
                        <th>정의</th> 
                    </tr>
                    <tr>
                        <td>닫혀 있음</td>
                        <td>· 어떤 집합에서 두 원소를 사용한 이항 연산 결과는 항상 그 집합에 속한다. </td>
                    </tr>
                    <tr>
                        <td>교환 법칙</td>
                        <td>· 이항 연산에 사용되는 두 원소의 위치를 바꾸어도 결과가 동일하다. </td>
                    </tr>
                    <tr>
                        <td>결합 법칙</td>
                        <td>· 이항 연산에 사용되는 세 원소의 위치를 바꾸어도 결과가 동일하다. </td>
                    </tr>
                    <tr>
                        <td>분배 법칙</td>
                        <td>
                            · 두 이항 연산에 대해 a(b + c) = ab + ac, (b + c)a = ba + ca인 성질<br>
                            · 각각을 좌분배 법칙, 우분배 법칙이라고하며 두 가지 모두를 만족해야 분배법칙을 만족한다고 한다. 
                        </td>
                    </tr>
                    <tr>
                        <td id = "identity-source">항등원</td>
                        <td>· 'a (이항 연산자) b = a' 가 항상 성립하는 경우, 'b는 (이항 연산자)에 대한 항등원'이라고 한다. </td>
                    </tr>
                    <tr>
                        <td id = "inverse-element">역원</td>
                        <td>
                            · 'a (이항 연산자) b = (이항 연산자)에 대한 항등원' 이 항상 성립하는 경우, 'b는 (이항 연산자)에 대한 역원'이라고 한다. <br>
                            · 역원을 구하려면 항등원이 반드시 있어야만 한다. <br>
                            · 덧셈의 항등원은 0이므로, 덧셈의 역원은 -a이다. 역원은 항상 주어진 수에 -가 붙으므로 반대수(opposite number)라고도 한다. <br>
                            · 곱셈의 항등원은 1이므로, 곱셈의 역원은 1/a이다. 역원은 항상 주어진 수를 분수로 만드므로 역수(reciprocal)이라고도 한다. <br>
                        </td>
                    </tr>
                </table>
            </div>
            <div class = "content2">
                <h3>수와 집합</h3>
                <h5>소박한 집합론(naive set theory)으로 수를 구분</h5>
                <p>
                    (그림)
                    · 구분 가능한 '원소'로 수를 집합하는 것을 말한다. <br>
                    · 예를 들어, 자연수의 원소와 정수의 원소는 서로 구분지을 수 있으므로 집합으로 나타낼 수 있다. <br>
                    · 하지만 소박한 집합론은 인간의 언어로 보편적 관념에 의존하므로 일상생활에서 사용함은 문제없으나, 고차원적으로 수학의 체계를 세우고 다루기에는 정확하지 않다. 
                </p>
                <h5 id = "axiom-set-theory">공리적 집합론(axiomatic set theory)으로 수를 구분</h5>
                <p>
                    · '연산'에 대한 공리로 수를 집합하는 것을 말한다. <br>
                    · 쉽게 말해 소박한 집합론에서의 '자연수', '정수', '실수' 처럼 특정한 수 집합을 지칭하는 단어가 있는 것이 아니라 <br>
                    · 수로 연산을 수행했을 때 연산이 가지는 성질만으로 수를 다루는 것이다. <br>
                    · 소박한 집합론과 달리 공리로 정확하게 수를 집합하므로 고차원적인 수 체계를 다루기에 적합하다. <br>
                    · 책에서는 <a href = "#binary-operation">🔗이항 연산의 성질</a>을 바탕으로 공리를 구축한다. 
                </p>
                <h5 id = "field">체(field)의 구조</h5>
                <p>
                    · 수 집합의 두 수가 이항 연산을 수행함에 있어서 다음 11가지 조건을 확인해보자 <br>
                </p>
                <div class = "content3">
                    1. 연산에 대해 닫혀있다. <br>
                    2. 연산에 대해 교환 법칙이 성립한다. <br>
                    3. 연산에 대해 결합 법칙이 성립한다. <br>
                    4. 연산에 대한 항등원이 존재한다. <br>
                    5. 연산에 대한 역원이 존재한다. <br>
                    <span class = "emphasis">(이 다음은 임의의 이항 연산을 추가 해서 보자 (분배 법칙이 성립하는지 보기 위함))</span><br>
                    6. 두 번째 연산에 대해 닫혀 있다. <br>
                    7. 두 번째 연산에 대해 교환 법칙이 성립한다. <br>
                    8. 두 번째 연산에 대해 결합 법칙이 성립한다. <br>
                    9. 첫 번째 연산과 두 번째 연산에 대해 분배 법칙이 성립한다. <br>
                    10. 두 번째 연산에 대해 항등원이 존재한다. <br>
                    11. 두 번째 연산에 대해 역원이 존재한다. (단, 0은 제외)<br>
                </div>
                <br>
                <p>
                    · 위의 공리를 모두 만족하는 '수 집합'을 체의 구조를 지닌다라고 한다. <br>
                    · 예를 들어, 유리수와 실수의 덧셈, 곱셈 연산은 위 공리를 모두 만족하여 체의 구조를 지닌다. <br>
                    · 이렇게 유리수와 실수처럼 체의 구조를 지니는 수 집합은 예외 없이 덧셈과 곱셈을 안전하고 자유롭게 쓸 수 있다. <br>
                    · 사칙 연산의 뺄셈, 나눗셈 연산은 교환법칙을 만족하지 않으므로 체의 구조를 지니지 않는다. <br>
                    · 뺄셈 대신 덧셈의 역원, 나눗셈 대신 곱셈의 역원을 사용하면 된다. <br>
                    · 정리하면 유리수 실수는 덧셈, 곱셈만에 체의 구조를 만족하므로 덧셈과 곱셈을 사용하자. <br>
                    (식)
                </p>
            </div>
            <div class = "content2">
                <h3>수의 표현</h3>
                <h5 id = "number-line">수직선(number line)</h5>
                <p>
                    · 실수(R)를 직선으로 표현한 것이다. <br>
                    · 직각으로 만나는 직선을 의미하는 수직선(perpendicular line)과 동음이의어이니 주의<br>
                    · 0을 기준으로 오른쪽은 양수 왼쪽은 음수이다. <br>
                    (그림)
                </p>
                <h6>절댓값(absolute value)</h6>
                <p>
                    · 수가 원점으로부터 떨어진 거리이다. <br>
                    <div class = "equation-h6">$|a|$</div>
                </p>
            </div>
            <div class = "content2">
                <h3>함수(function)</h3>
                <p>
                    (그림)<br>
                    · '두 집합'에서 첫 번째 집합의 원소가 두 번째 집합의 어떤 원소에 대응하는 관계
                </p>
                <h5>정의역(domain)</h5>
                <p>
                    · 첫 번째 집합, 즉 함수에 대입할 값의 집합
                </p>
                <h5>공역(codomain)</h5>
                <p>
                    · 두 번째 집합, 즉 함수에 값을 대입했을 때 나올 수 있는 모든 결과의 집합<br>
                    · 공역 co-domain... co-worker(동료)처럼, co 즉 같이 묶여 있다라는 느낌으로 이해하기. 
                </p>
                <h5>치역(range)</h5>
                <p>
                    · 정의역의 원소에 대응되는 공역의 원소 집합, 즉, 공역 중 대입할 값을 넣었을 때의 결과 값(정의역과 대응되는 값)<br>
                    · 치역의 치는 値, 값 치자로 값의 영역으로 이해하면됨 즉, 정의역을 함수에 넣었을 때 나오는 값
                </p>
                <h5>함수의 성립 조건</h5>
                <div class = "content3">
                    · 정의역의 모든 원소는 공역의 원소에 대응해야만 한다. (함수에 넣을 값은 반드시 유효한 값이다. )<br>
                    · 정의역의 원소 하나는 공역의 어느 한 원소에만 대응해야 한다. (함수에 값이 하나 들어갔는데 결과가 두 개 이상이 나오면 상식적으로 틀리다.)
                </div>
                <h5>전사 함수(全射: surjection, 위로의 함수(on to))</h5>
                <!-- · 全(온전할 전(전부할때 전자))射(쏠 사(발사 할때 사))즉, 공역이 정의역 모두와 대응됨<br> -->
                <div class = "content3">
                    · 공역의 원소와 정의역의 원소가 1:1대응 하는가? > <span class = "emphasis"> X </span><br>
                    · 공역의 모든 원소가 정의역과 대응하는가? (공역 = 치역인가? ) > <span class = "emphasis"> O </span><br>
                </div>
                <p>
                    · 全射, 즉, 공역의 모든 원소(全)가 정의역의 원소와 대응(射)되는 함수<br> 
                    (그림)
                </p>
                <h5>단사 함수(單射: injection, 일대일 함수(one-to-one))</h5>
                <!-- · 單(홀로 단)射(쏠 사)즉, 공역이  -->
                <div class = "content3">
                    · 공역의 원소와 정의역의 원소가 1:1대응 하는가? > <span class = "emphasis"> O </span><br>
                    · 공역의 모든 원소가 정의역과 대응하는가? (공역 = 치역인가? ) > <span class = "emphasis"> X </span><br>
                </div>
                <p>
                    · 單射, 즉, 공역의 원소 각각은  정의역 원소 각각(單)에만 대응되는 함수 즉, 1:1대응<br>
                    · 대응되지 않는 공역이 존재할 수 있음<br>
                    (그림)
                </p>
                <h5>전단사 함수(bijection, one-to-one and on to)</h5>
                <div class = "content3">
                    · 공역의 원소와 정의역의 원소가 1:1대응 하는가? > <span class = "emphasis"> O </span><br>
                    · 공역의 모든 원소가 정의역과 대응하는가? (공역 = 치역인가? ) > <span class = "emphasis"> O </span><br>
                </div>
                <p>
                    · 전사 함수와 단사 함수의 조건을 모두 만족하는 함수<br>
                    · 공역과 정의역의 모든 요소가 빠짐없이 1:1 대응<br>
                    (그림)
                </p>
                <h5>합성 함수(function composition)</h5>
                <p>
                    · 2개의 함수를 연쇄적으로 이어 하나의 함수로 만드는 연산 <br>
                    (식) <br>
                    · 합성함수를 이항 연산으로 규정하면 합성함수는 결합법칙이 성립한다. 
                    <h6> 합성 함수의 결합 법칙 증명</h6>
                </p>
                <h5>항등함수(identity function)</h5>
                <p>
                    · 정의역과 공역이 '동일한 값'으로 대응되는 함수, 'id'로 표현한다. <br>
                    · 연산에서의 <a href = "#identity-source">🔗항등원</a>과 동일한 역할을 수행한다. <br>
                    · 즉, 합성함수 연산에서의 항등원 역할이라고 보면 된다. <br>
                    (그림)<br>
                </p>
                <div class = "equation-h5">
                    $id \circ f = f, f \circ id = f$
                </div>
                <h5>역함수(inverse function)</h5>
                <p>
                    · 연산에서의 <a href = "#inverse-element">🔗역원</a>과 동일한 역할을 수행한다. <br>
                    · 즉, 합성함수 연산에서의 역원 역할이라고 보면 된다. <br>
                    · 반드시 전단사 함수만 역함수가 될 수 있음에 주의! <br>
                    <div class = "equation-h5">
                        $f^{-1} \circ f = id, f \circ f^{-1} = id$
                    </div>
                </p>
                <h5>곱집합(cartesian product)</h5>
                <p>
                    · 두 집합이 있을 때, 그 두 집합의 원소를 순서쌍으로 묶은 원소의 집합<br>
                    · 곱집합은 순서쌍의 요소를 수직으로 배치하는 성질이 있다. <br>
                    · 이 성질을 때문에 두 실수 집합을 곱집합으로 나타내면 좌표 평면을 만들 수 있다. 
                </p>
            </div>
            <div class = "content2">
                <h3>데카트르 좌표계(cartesian coordinate system)</h3>
                <p>
                    · 이렇게 두 실수 집합의 곱집합으로 만들어진 좌표 평면 즉, 평면 공간을 데카르트 좌표계라고 한다. <br>
                    · 곱집합의 원어가 데카르트 곱(cartesian product)임을 생각해보면 둘은 동일한 개념이다. <br>
                    · 공리적 집합론으로 규정하기 때문에 데카르트 좌표계의 두 수 집합을 실수 집합이라 하지 않고 체의 구조를 지니는 수 집합이라고 한다. <br>
                </p>
                <h5>사분면</h5>
                <p>
                    · 데카르트 좌표계는 2개의 수직선이 원점(0, 0)에서 접하여 수직으로 배치되어 나뉘어있고 4개의 면을 가진다. <br>
                    · 각각의 면을 시계 반대 방향 순서로 제1사분면, 제2사분면, 제3사분면, 제4사분면이라고 한다. 
                </p>
                <h5>좌표(coordinate)</h5>
                <p>
                    · 데카르트 좌표계 상의 원소는 곱집합과 같이 순서쌍으로 표현하며 좌표라고 한다. <br>
                    · <a href = "#number-line">🔗수직선(number line)</a>에서와 동일하게 점 또는 원점으로 부터의 화살표로 표현한다. <br>
                    (그림)<br>
                    · 즉 수직선 -> 평면으로 바뀌었을 뿐 수직선에서 수를 다루는 방식과 매우 유사하다. <br>
                </p>
                <h5>벡터 공간(vector space)</h5>
                <p>
                    · 두 개 이상의 실수를 곱집합으로 묶어 형성된 집합을 <a href = "#axiom-set-theory">🔗공리적 집합론</a>으로 규정하면 벡터 공간(vector space)라고 한다. <br>
                    · 수직선(1차원)에서의 점의 이동처럼 평면 좌표(2차원)에서의 이동을 위해서는 새로운 연산을 고안해야한다. <br>
                    · 데카르트 좌표계는 두 실수의 집합이므로 실수가 지니는 연산의 성질(공리적 집합론)을 바탕으로 연산을 설계해야한다. <br>
                    · 데카르트 좌표계는 두 실수 집합이고, 실수 연산은 <a href = "#field">🔗체(field)의 구조</a>를 지닌다. 
                </p>
                <h6>벡터(vector)</h6>
                <p>
                    · 벡터 공간에서의 원소
                </p>
                <h6>벡터의 크기(= 노름(Norm))</h6>
                <p>
                    · 원점으로부터의 최단거리이다. <br>
                    · 즉, 벡터의 크기는 벡터의 길이이다. <br>
                    · 원점과 벡터를 연결하여 최단거리를 만든 후 직각삼각형을 그려 피타고라스 정리를 사용하여 구한다. <br>
                </p>
                <div class = "equation-h6">
                    $|\vec{v}|=||\vec{v}||=\sqrt{a^{2}+b^{2}}$
                </div>
                <h6>단위 벡터(unit vector)</h6>
                <p>
                    · 크기가 1인 벡터이다. <br>
                    · $\hat{v}$는 $\vec{v}$를 단위 벡터로 표현한 것이다. 기호 $\hat{}$ 은 'hat'(모자 같이 생겨서)이라고 읽는다. <br>
                    · 단위 벡터는 벡터 / 벡터 크기이다. <br>
                    · <a href = "#vector-operation">🔗벡터 공간에서의 스칼라 곱셈의 성질</a>을 이용해 임의의 벡터 v를 벡터 v의 크기로 나누면 된다. <br>
                    · 벡터를 단위벡터로 만드는 작업을 정규화(normalize)라고 한다. 
                </p>
                <div class = "equation-h6">
                        $\hat{v} = \frac{\vec{v}} {|\vec{v}|}$
                </div>
                <h6>스칼라(scalar)</h6>
                <p>
                    · 체의 구조를 지니는 수 집합의 원소 <br>
                    · 벡터 공간의 두 실수 x, y각각 공리적 집합론의 관점에서 '체 집합의 원소'라고 함 즉, 스칼라임 <br>
                    (그림)
                </p>
                <h5 id = "vector-operation">벡터 공간의 연산</h5>
                <p>
                    · 체가 갖는 연산의 성질에 기반하여 벡터 공간의 연산이 갖는 성질을 아래 표로 정리하였다. <br>
                    · 이를 벡터 공간의 8가지 공리라고한다. 
                </p>
                <table class = "math-vector-space">
                    <tr>
                        <th>분류</th>
                        <th>공리</th>
                        <th>수식</th>
                    </tr>
                    <tr>
                        <td rowspan = 4>벡터의 합</td>
                        <td>벡터 합의 결합 법칙</td>
                        <td>$\vec{u}+(\vec{v}+\vec{w})=(\vec{u}+\vec{v})+\vec{w}$</td>
                    </tr>
                    <tr>
                        <td>벡터 합의 교환법칙</td>
                        <td>$\vec{u}+\vec{v}=\vec{v}+\vec{u}$</td>
                    </tr>
                    <tr>
                        <td>벡터 합의 항등원</td>
                        <td>$\vec{v}+\vec{0}=\vec{v}$</td>
                    </tr>
                    <tr>
                        <td>벡터 합의 역원</td>
                        <td>$\vec{v}+(-\vec{v})=\vec{0}$</td>
                    </tr>
                    <tr>
                        <td rowspan = 4>스칼라 곱셈</td>
                        <td>스칼라 곱셈의 호환성</td>
                        <td>$a(b\vec{v})=(ab)\vec{v}$</td>
                    </tr>
                    <tr>
                        <td>스칼라 곱셈의 항등원</td>
                        <td>$1·\vec{v}=\vec{v}$</td>
                    </tr>
                    <tr>
                        <td>벡터의 합에 대한 분배 법칙</td>
                        <td>$a(\vec{u}+\vec{v})=a\vec{u}+a\vec{v}$</td>
                    </tr>
                    <tr>
                        <td>스칼라 덧셈에 대한 분배법칙</td>
                        <td>$(a+b)\vec{v}=a\vec{v}+b\vec{v}$</td>
                    </tr>
                    
                </table>
            </div>
            <div class = "content2">
                <h3>선형 결합식과 선형 종속과 선형 독립</h3>
                <h5>선형 결합식</h5>
                <p>
                    · n개의 스칼라와 벡터를 결합하여 새로운 벡터를 생성하는 수식을 말한다. <br>
                    · 선형 종속, 선형 독립을 알아볼 때에는 선형 결합의 결과가 $\vec{0}$즉, 영벡터인 경우를 사용한다. <br>
                </p>
                <div class = "equation-h5">
                    $a_{1}\vec{v_{1}} + a_{2}\vec{v_{2}} + a_{3}\vec{v_{3}} + ··· + a_{n}\vec{v_{n}} = \vec{v^{'}}$
                </div>
                <p>
                    · 벡터가 선형 종속인지 독립인지 확인하려면 다음 식이 필요하다. 
                </p>
                <div class = "equation-h5">
                    $a_{1}\vec{v_{1}} + a_{2}\vec{v_{2}} + a_{3}\vec{v_{3}} + ··· + a_{n}\vec{v_{n}} = \vec{0}$
                </div>
                <h5>선형 종속</h5>
                <p>
                    · 선형 결합식의 결과가 $\vec{0}$ 일 때, 스칼라가 0이 아니어도(즉 0인 경우 포함) 영벡터가 나올수 있다면, 선형 결합식에 있는 벡터들은 선형 종속 관계라고 한다. <br>
                    · 즉 n개의 벡터가 서로 같은 선 상에 놓여진 상태이다. 
                    <div class = "equation-h5">예: $2 · (1, 2) + -1 · (2, 4) = \vec{0}$</div>
                </p>
                <h5>선형 독립</h5>
                <p>
                    · 선형 결합식의 결과가 $\vec{0}$ 일 때, 스칼라가 0이어야만 영 벡터가 나올 수 있다면, 선형 결합식에 있는 벡터들은 선형 독립 관계 라고 한다. <br>
                    · 즉, n개의 벡터가 모두 다른 선 상에 놓여진 상태이다. <br>
                    · 선형 독립 관계를 가지는 벡터들로는 2차원 벡터 공간 상의 모든 벡터를 생성할 수 있다. <br>
                    · 선형 독립 관계는 2개의 벡터만이 가질 수 있다. 
                    <div class = "equation-h5">$0 · \vec{v_{1}} + 0 · \vec{v_{2}} = \vec{0}$</div>
                </p>
                <h6>선형 독립에 2개의 벡터만 사용되는 이유 증명</h6>
                <div class = "equation-h6">
                    우선 2개의 벡터만 사용되어야하는 이유를 알아보기 위해 선형 독립 관계인 3개의 벡터를 선형 결합하는 식을 살펴보자. <br>
                    <br>
                    $a\vec{v_{1}} + b\vec{v_{2}} + c\vec{v_{3}} = \vec{0}$ <br>
                    <br>
                    3개의 백터가 모두 선형 독립 관계를 가지려면 스칼라 $a$, $b$, $c$는 모두 0이어야한다. 
                    <br>
                    이제 앞에서 두 번째 까지의 항을 선형 결합해보자. 두 항은 선형 독립 관계 이므로, 위 식의 끝 항에 $-1$을 곱한 $-c\vec{v_{3}}$도 생성 가능하다. <br>
                    <br>
                    $-c\vec{v_{3}} + c\vec{v_{3}} = \vec{0}$<br>
                    <br>
                    이 경우 스칼라 $c$가 0이어도 성립하지만, 0이 아니어도 위 선형 결합식이 성립한다. <br>
                    즉, 스칼라 $c$가 0이 아닌 경우는 선형 종속 관계에 해당하여 선형 독립 관계를 만족하지 못한다. <br>
                    따라서, 선형 독립 관계여야한다면 반드시 2개의 벡터여야 하고<br>
                    반드시 2개의 벡터여야만 2차원 벡터 상의 모든 벡터를 생성 가능하다. 
                </div>
                <h6>기저(Basis)</h6>
                <p>
                    · 선형 독립 관계를 가지는 벡터들의 집합<br>
                </p>
                <div class = "equation-h6">
                    $(2, 1), (1, 3)$로 이루어진 집합은 기저이다. 
                </div>
                <h6>기저 벡터(Basis Vector)</h6>
                <p>
                    · 기저(Basis)에 속한 벡터 원소들 각각 <br>
                    · 기저의 원소가 1개면 1차원, 2개면 2차원, 3개면 3차원 ··· n개면 n차원 <br>
                    · 기저 벡터를 다른 값으로 변경하면 기저벡터로 부터 세워진 벡터 공간의 모든 원소가 바뀐다. 이는 선형 변환의 기본 원리가 된다. <br>
                </p>
                <div class = "equation-h6">
                    $(2, 1), (1, 3)$에서 $(2, 1)$과 $(1, 3)$각각을 기저 벡터라고 한다. 
                </div>
                <h6>표준 기저(standard basis)</h6>
                <p>
                    · 기저의 원소가 중 단위 벡터만 원소로 구성된 것<br>
                </p>
                <div class = "equation-h6">
                    $R^{2}$ 튜플 상 $(1, 0), (0, 1)$은 표준 기저이다. <br>
                    $R^{3}$ 튜플 상 $(1, 0, 0), (0, 1, 0), (0, 0, 1)$은 표준 기저이다.  
                </div>
            </div>
            <div class = "content2">
                <h3>삼각 함수(trigonometric function)</h3>
                <h5>삼각비(trigonometric ration)</h5>
                <figure><img src = "../img/Trigonometry_triangle.png"><figcaption>출처: https://ko.wikipedia.org/wiki/%EC%82%BC%EA%B0%81%ED%95%A8%EC%88%98</figcaption></figure><br>
                <p>
                    · 직각 삼각형을 구성한는 세 변에서 두 변을 뽑아 각각의 비례관계를 나타낸 것. <br>
                    · $\angle A$는 사잇각이다. θ(세타)라고 하자, 사잇각은 0˚ 초과, 90˚ 미만의 값이어야만 한다. <br>
                    · hypotenuse(빗변), opposite(높이), adjacent(밑변)이 있고 직각삼각형을 밑변이 바닥에 닿도록 세운 상태로 둬보자. <br>
                    · 그 경우 다음과 같은 삼각비가 형성된다. 
                </p>
                <div class = "equation-h5">
                    $sinθ = \frac {a} {h}$ <br>
                    $cosθ = \frac {b} {h}$ <br>
                    $tanθ = \frac {a} {b}$
                </div>
                <h5>삼각 함수(trigonometric function)</h5>
                <figure><img src = "../img/trigonometric-function.png"><figcaption>출처: https://ko.wikipedia.org/wiki/%EC%82%BC%EA%B0%81%ED%95%A8%EC%88%98#/media/%ED%8C%8C%EC%9D%BC:Circle-trig6.svg</figcaption></figure><br>
                <p>
                    · 이제 이 직각 삼각형을 데카르트 좌표계에 배치하고 $\angle A$ θ(세타)의 범위를 실수 전체로 확장하자 이것을 삼각함수(trigonometric function)라고 한다. <br>
                    · 삼각함수는 직각삼각형에서 출발했지만 반지름의 길이가 1인 단위 원(unit circle)을 사용하면 쉽게 표현할 수 있다. <br>
                    · 단위 원은 반지름이 1이므로 단위원 속의 직각 삼각형의 빗변의 길이 $h$ 는 1이다. 
                </p>
                <h6>원주율(pi)</h6>
                <p>
                    · 원의 지름이 1일 때 그 둘레의 길이가 약 3.141592라는 뜻이다. (1cm면 약 3.141592cm, 1m이면 약 3.141592m...) <br>
                    · 즉, 원의 지름에 대한 원주(원 둘레)의 비율 약 3.141592...이다. 순환하지 않는 무한 소수이며 π(파이)로 나타낸다. <br>
                    · 원주율을 활용하면, 원의 둘레의 길이를 구하기 위해 일일히 줄자로 잴 필요 없이 그 원의 지름의 길이를 원주율로 곱하면 된다. 
                </p>
                <h6>각도법(degree)</h6>
                <p>
                    · 0˚ ~ 360˚로 각도를 나타내는 방법 <br>
                    · 각도법은 360이라는 큰 수를 사용하고 약수가 많은 수라 수를 잘 나누어 일상 생활에서 다양하게 쓰도록 만든 것이다. <br>
                </p>
                <h6>호도법(radian)</h6>
                <figure><img src = "../img/radian.png"><figcaption>출처: https://namu.wiki/jump/RhXB9%2BU1Zy4FkTm13Rsg%2BLEB8eTMkOzuD8HLoEcYIXi6D0pJJDxjFywrb5msiEqACph1VFKqT0xaaybkFGQaaH73P6prTs%2FKb3v4bOXBzLzUdYOMgQV1gpHUcX%2FJ4sgN</figcaption></figure>
                <h6></h6>
                <p>
                    · 반지름의 길이가 r인 원의 호의 길이가 r이 되는 경우의 중심각이 기준이다. 이를 '1라디안'( $1(rad)$ )이라고 한다. <br>
                    
                </p>
                <div class = "equation-h6">
                    반지름 r인 원, 특정 각에 대한 호의 길이를 l이라하면<br>
                    원주율에 의해 (원주율은 모든 원에 대해 일정하므로) <br>
                    <br>
                    $\frac {l} {r}$ <br>
                    <br>
                    이 성립한다. 
                </div>
                <h6></h6>
                <p>
                    · 벡터가 단위량인 1을 기준으로한 단위벡터를 정의한 것처럼 각도도 이렇게 하면 편할 것이다. <br>
                    · 지름이 1인 원의 원주는 $2πr$ 중심각은 $360˚$이므로 다음이 성립한다. 
                </p>
                <div class = "equation-h6">
                    $360˚ = 2π(rad)$<br>
                    $180˚ = π(rad)$ <br>
                    <br>
                    $1(rad) = \frac{180˚} {π}$<br>
                    $1˚ = \frac{π} {180˚}(rad)$ <br>
                </div>
                <h6>sin 함수</h6>
                <h6>cos 함수</h6>
                <h6>회전과 관련된 계산에 유용한 공식</h6>
                <p>
                    · 단위 원에서 반지름 선상에 위치한 모든 점의 좌표는 $(cosθ, sinθ)$로 각 θ(세타)에 의해 결정된다. <br>
                    ·
                </p>
                <div class = "equation-h6">
                    $cos^{2}θ + sin^{2}θ = 1$
                </div>
                <h6>회전과 관련된 계산에 유용한 공식 증명</h6>

                <h6>삼각함수를 사용한 물체의 회전 구현</h6>
            </div>
            <div class = "content2">
                <h3>4장 삼각함수: 회전을 위한 수학</h3>
                <p>
                    · 회전은 원의 궤적을 따라 움직이는 이동을 정의하는 것이라서 원과 밀접한 연관이 있는 삼각함수를 알아야한다. 
                </p>
                <h5>삼각함수</h5>
                <figure><img src = "../img/Trigonometry_triangle.png"><figcaption>출처: https://ko.wikipedia.org/wiki/%EC%82%BC%EA%B0%81%ED%95%A8%EC%88%98</figcaption></figure><br>
                <p>
                    · 삼각함수를 보기 전에 <span class = "keyword">삼각비(trigonometric ratio)</span>를 보면, 삼각비란 직각 삼각형을 구성한는 세 변에서 두 변을 뽑아 각각의 비례관계를 나타낸 것. <br>
                    · $\angle A$는 사잇각이다. θ(세타)라고 하자, 사잇각은 0˚ 초과, 90˚ 미만의 값이어야만 한다. <br>
                    · hypotenuse(빗변), opposite(높이), adjacent(밑변)이 있고 직각삼각형을 밑변이 바닥에 닿도록 세운 상태로 둬보자. <br>
                    · 그 경우 다음과 같은 삼각비가 형성된다. 
                    <div class = "equation-h5">
                        $sinθ = \frac {a} {h}$ <br>
                        $cosθ = \frac {b} {h}$ <br>
                        $tanθ = \frac {a} {b}$
                    </div><br>
                </p>
                <p>
                    · 이제 삼각함수를 알아보자, 삼각비의 사잇각$\angle A$의 범위를 실수 전체(집합R)로 확장한 대응 관계를 <span class = "keyword">삼각함수(trigonometric function)</span>라고 한다. <br>
                    <div class = "equation-h5">
                        단위 원의 반지름을 빗변으로 하는 직각 삼각형은 삼각비에 의해<br>
                        <br>
                        밑변의 길이가 $cosθ$ <br>
                        높이가 $sinθ$가 된다. <br>
                        <br>
                        이것을 피타고라스 정리 $a^{2}+b^{2}=c^{2}$ 에 대입하면 다음과 같다. <br>
                        <br>
                        $cos^{2}θ + sin^{2}θ = 1$ <span class = "formula">식 1</span><br> 
                        <br>
                        이는 단위원이 아닌 경우도 성립한다. 확인해보자<br>
                        <br>
                        <br>
                        반지름을 r로 두면<br>
                        빗변의 길이는 r이 된다. <br>
                        이는 벡터 개념으로 보면 길이가 1인 벡터와 평행하고 길이가 r배만큼 증가한 것이다. <br>
                        <br>
                        따라서,<br>
                        밑변의 길이는  $r · cosθ$ <br>
                        높이는 $r · sinθ$ 가 된다. <br>
                        <br>
                        이것을 피타고라스 정리에 대입하면 다음과 같다. <br>
                        <br>
                        $r^{2}cosθ^{2} + r^{2}sinθ^{2} = r^{2}$ <br>
                        $cos^{2}θ + sin^{2}θ = 1$ <br>
                        <br>
                        결국 반지름$r$과 상관 없이 <span class = "formula">식 1</span> 이 성립한다. 
                    </div>
                </p>
                <h6>삼각함수의 성질</h6>
                <h6>각의 측정법</h6>
                <h5>삼각 함수를 활용한 물체의 회전</h5>
                <h5>삼각 함수의 역함수</h5>
                <h5>극좌표계</h5> 
            </div>
            <div class = "content2">
                <h3>5장 행렬: 가상 세계의 변환 도구</h3>
                <h5>선형성: 예측 가능한 비례 관계</h5>
                <p>
                    · 선형성은 직선으로 쭉 뻗은 진선의 형태를 의미한다. <br>
                    · 수학에서 명확함을 위해 선형성을 참 거짓을 명확히 해주는 명제로 나타내면 다음과 같다. <br>
                </p>
                <div class = "equation-h5" style = "text-align:left">
                    가법성: $f(x_{1} + x_{2}) = f(x_{1}) + f(x_{2})$<br>
                    <br>
                    1차 동차성: $f(kx) = kf(x)$<br>
                    을 만족하면 선형성을 지닌다고 한다. 
                </div>
                <h6>선형 함수</h6>
                <p>
                    · 1차 동차성, 가법성을 모두 만족하는 선형 함수는 아래 뿐이다. 
                </p>
                <div class = "equation-h6">
                    $y = ax$
                </div>
                <h6></h6>
                <p>
                    · 즉, 선형 함수는 원점을 반드시 지나야만 한다. <br>
                    · $y = ax + b$의 경우 선형적으로 생겼으나 가법성을 만족하지 못한다. 따라서 선형 함수가 아니다. <br>
                    · 직선의 형태를 띰에도 선형성을 만족하지 못하는 이유는 선형성은 단지 곧게 뻗은 직선을 의미하는 것이 아니다. <br>
                    · 선형성은 순수비(ratio)여야 한다. 따라서 어떤 값을 대입했을 때 쉽게 출력값을 알 수 있어야하고, <br>
                    · 역함수 $y = \frac{1} {a}x$를 사용하여 출력값으로 부터 쉽게 입력값을 역추적할 수 있어야한다. 
                </p>
                <h6>벡터 공간의 선형 변환</h6>
                <p>
                    · 2차원 벡터 공간에서 선형성(가법성, 1차 동차성을 만족)을 만족하려면 다음과 같아야할 것이다. <br>
                    · x, y 각각에 대해 선형성을 만족하려면 ax와 by같이 단순 비의 형태여야하고 <br>
                    · 이들을 섞은 결과는 ax + by와 같은 형태여야할 것이다. <br>
                    · 이 경우들을 적용한 것이 아래의 함수로 아래 함수는 벡터 공간에서 선형성을 만족하는 함수이다. <br>
                    · 이렇게 선형성을 유지시켜주는 함수를 선형 변환(linear transformation)이라고 한다. 
                </p>
                <div class = "equation-h6">
                    $f(\vec{v}) = f(x, y) = (ax+by, cx+dy)$
                </div>
                <h5>행렬</h5>
                <p>
                    · 행렬은 수를 행과 열에 맞추어 사각형의 형태로 나열한 테이블이다. <br>
                    · 행렬은 선형 변환과 벡터를 나타낼 때 사용한다. 선형 변환에서는 열과 행의 크기가 같은 정방행렬(square matrix)를 사용한다. <br>
                    · 정방 행렬은 열과 행의 크기에 따라 '숫자 X 숫자 크기의 정방행렬' 이라고 한다. (예 2 X 2 크기의 정방행렬; 행과 열의 크기가 2인 정방 행렬)
                </p>
                <h6>행렬의 기본 연산</h6>
                <div class = "content3">
                    · 행렬 + 행렬: 행과 열의 크기가 같은 경우만 가능 <br>
                    · 스칼라 * 행렬: 모든 행렬의 원소에 스칼라를 곱함 <br>
                    · 행렬의 전치: 모든 행과 열을 바꿈 (예: 2 X 3 → 3 X 2) <br>
                    · 행 * 행: 중요하므로 바로 밑의 '행렬의 곱셈'에서 다룸
                </div>
                <h6>행렬의 곱셈</h6>
                <div class = "content3">
                    · 교환 법칙 X <br>
                    · 분배 법칙 O <br>
                    · 결합 법칙 O <br>
                    · 전치 연산의 특징: $(A·B)^{t} = B^{t}·A^{t}$
                </div>
                <h6></h6>
                <p>
                    · 벡터 공간에서의 선형 변환 함수  $f(\vec{v}) = f(x, y) = (ax+by, cx+dy)$는 다음 행렬곱과 같다. 
                </p>
                <div class = "equation-h6" style = "text-align:left;">
                    $\begin{bmatrix}a&b\\c&d\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}=\begin{bmatrix}ax+by\\cx+dy\end{bmatrix}$<br>
                    <br>
                    즉, 어떤 정방 행렬 * 벡터 = 새로운 벡터
                </div>
                <h6></h6>
                <p>
                    · 위 행렬 곱 수식 자체는 2차원 벡터에 선형 변환을 적용 하여 새로운 벡터를 생성하는 작업에 대응된다. <br>
                    · 이 식에서 a, b, c, d가 있는 정방행렬이 선형 변환 함수와 대응되는 선형 변환 행렬이 된다. 
                </p>
                <h6>정방 행렬의 곱셈</h6>
                <p>
                    · 앞서 설명한 행렬 곱의2X2정방행렬이 선형 변환 함수와 대응된다고 했다. <br>
                    · 이 정방 행렬의 곱은 합성함수와 대응된다. <br>
                    · 행렬의 곱셈은 결합 법칙을 만족한다. 
                </p>
                <h6><span class = "ref">참고</span> 열 기준 행렬과 행 기준 행렬</h6>
                <p>
                    · 수학에서는 벡터를 열벡터로 나타내는 <span class = "keyword">열 기준 행렬</span>을 주로 사용<br>
                    · 열 기준 행렬은 연산 방향이 일반적인 연산 방향과 반대인 역방향으로 왼쪽에서 오른쪽이다. (열역)<br>
                    · 대표적인 사례로 게임 그래픽스 라이브러리인 OpenGL, 그리고 게임 엔진인 유니티가 있다. 
                </p>
                <div class = "equation-h6">
                    $\begin{bmatrix}a&b\\c&d\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}=\begin{bmatrix}ax+by\\cx+dy\end{bmatrix}$
                </div>
                <h6></h6>
                <p>
                    · 하지만 컴퓨터에서 행렬을 응용할 때에는 <span class = "keyword">행 기준 행렬</span>을 쓰기도 한다. <br>
                    · 행 기준 행렬은 연산 방향이 일반적인 연산 방향과 같이 순방향으로 오른쪽에서 왼쪽이다. (행순)<br>
                    · 대표적인 사례로 게임 그래픽스 라이브러리인 다이렉트 X, 그리고 게임 엔진인 언리얼이 행 기준 행렬을 사용한다. 
                </p>
                <div class = "equation-h6">
                    $\begin{bmatrix}x&y\end{bmatrix}\begin{bmatrix}a&c\\b&d\end{bmatrix}=\begin{bmatrix}ax+by&cx+dy\end{bmatrix}$
                </div>
                <h6></h6>
                <p>
                    · 열기준 행렬과 행기준 행렬의 연산은 전치를 통해 서로 변환할 수 있다. <br>
                    · 이 책은 열 기준 행렬을 사용하여 모든 행렬을 표현하였다. 
                </p>
                <div class = "equation-h6">
                    $(A·\vec{v})^T = \vec{v}^{T}·A^{T}$
                </div>
                <h5>행렬의 설계</h5>
                <p>
                    · $R^{2}$상의 임의의 $\vec{v}$를 선형 변환한 $\vec{w}$를 구하는 행렬의 설계 방법은 아래와 같다. 
                </p>
                <div class = "equation-h5" style = "text-align:left;">
                    우선 임의의 벡터를 선형 변환하기 위해 <br>
                    벡터 공간 V에 임의의 벡터인 $\vec{v}=(x,y)$를 생성해보자<br>
                    간편한 계산을 위해 선형 독립 관계인 표준 기저 벡터를 사용, 선형 결합식에 대입하면<br>
                    선형 결합식에 의해<br>
                    <br>
                    $\vec{v}=x(1,0)+y(0,1)=(x,y)$ <span class = "formula">식1</span><br>
                    <br>
                    이 성립한다. <br>
                    <br>
                    <br>
                    이제 $\vec{v}$를 선형 변환하기 위해 선형 결합식에 의해 $\vec{v}$를 선형변환한 $\vec{w}$를 생성하면<br>
                    <br>
                    $\vec{w}=x(a,c)+y(b,d)=(ax+by, cx+dy)$ <span class = "formula">식2</span><br>
                    <br>
                    위 식을 행렬곱의 형태로 나타내면 <br>
                    즉, $R^{2}$ 상의 $\vec{v}$를 선형 변환한 결과 $\vec{w}$는 <br>
                    <br>
                    $\begin{bmatrix}a&b\\c&d\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}=\begin{bmatrix}ax+by\\cx+dy\end{bmatrix}$<br>
                    $\begin{bmatrix}a&b\\c&d\end{bmatrix}\vec{v}=\vec{w}$<br>
                    <br>
                    이다. <br>
                    <br>
                    여기서 $\vec{v}$를 생성하는 선형 결합식<span class = "formula">식1</span>과 $\vec{w}$를 생성하는 선형 결합식 <span class = "formula">식2</span>를 비교해보면<br>
                    행렬$\begin{bmatrix}a&b\\c&d\end{bmatrix}$의(a, c)와 (b, d)는 서로 선형 독립인 벡터임을 알 수 있다. <br>
                    <br>
                    즉, 2X2 크기의 정방행렬$\begin{bmatrix}a&b\\c&d\end{bmatrix}$를 설계하여 원하는 선형 변환 행렬을 만들 수 있다. 
                </div>
                <p>
                    · 위 행렬 설계에 대한 설명을 잘 이해하고 아래에서 부터 선형 변환 행렬을 만들고 이해해보자. 
                </p>
                <h6>크기 변환 행렬(scale transformation matrix)</h6>
                <p>
                    · 어떤 벡터의 크기를 x는 a만큼 y는 b만큼 변환하는 행렬<br>
                </p>
                <div class = "equation-h6">
                    $S=\begin{bmatrix}a&0\\0&b\end{bmatrix}$
                </div>
                <h6>회전 변환 행렬(rotation transformation matrix)</h6>
                <p>
                    · 어떤 벡터를 주어진 각θ로 회전하는 행렬
                </p>
                <div class = "equation-h6">
                    $R_{θ}=\begin{bmatrix}cosθ&-sinθ\\sinθ&cosθ\end{bmatrix}$
                </div>
                <h6>전단 변환 행렬(shear transformation matrix)</h6>
                <h6>삼각함수의 덧셈 정리</h6>
                <h5>역행렬</h5>
                <h6>역행렬의 존재를 판별하는 행렬식</h6>
                <h6>크기 변환 행렬의 역행렬</h6>
                <h6>전단 변환 행렬의 역행렬</h6>
                <h6>회전 변환행렬의 역행렬</h6>
                <h6>행렬 곱의 역행렬</h6>
            </div>
            <div class = "content2">
                <h3>6장 아핀 공간: 움직이는 가상 세계의 구축</h3>
                <h5>이동 변환을 위한 아핀 공간</h5>
                <h5>아핀 공간의 구성 요소</h5> 
                <h6>점</h6>
                <h6>이동 벡터</h6>
                <h6>아핀 공간의 성질</h6>
                <h5>아핀 결합</h5>
                <h6>두 점의 결합</h6>
                <h5>선 그리기 알고리즘</h5>
                <h6>벡터를 모니터의 점으로 표현</h6>
                <h6>선 그리기 알고리즘</h6>
                <h6>라인 클리핑 알고리즘</h6>
            </div>
        </div>
    </section>
</body>
<script src = "https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
<script src = "../js/common.js" type = "module"></script>
<script src = "../js/Index.js" type = "module"></script>
</html>