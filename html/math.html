<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>자료실</title>
        <link rel = "stylesheet" href = "../css/common.css">
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
        </script>
        <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
        <link rel = "stylesheet" href = "../css/math.css">
    </head>
    <body>
        <section class = "layout">
            <div class = "sidebar"></div>
            <div class = "content"></div>
            <div class = "body">
                <div class = "rights">개인 공부용이며, 복사, 배포를 금지합니다. <br>
                    검색은 ctrl + f를 사용하여 원하는 키워드를 입력한 후 찾으면됩니다. <br>
                    만약 내용상 오류가 있어 수정을 원한다면 게시판에 문의부탁드립니다. (구현 예정)
                </div>    
                <h1>게임 수학 정리</h1>
                <div class = "info">
                    이득우의 게임 수학(이득우 지음)을 개인적으로 정리한 내용입니다. 
                </div>
                <div class = "content2">
                    <h2>명제와 공리(axiom)</h2>
                    <p>
                        · 명제란 '참'과 '거짓'으로 구분할 수 있는 '객관적 사태'가 포함된 문장이다. <br>
                        · 공리란 명제 중에서도 증명할 필요가 없는 명백한 기본 명제를 말한다. (예를 들어, 1 + 1 = 2는 너무나 명백하여 증명할 필요가 없다. )<br>
                    </p>
                </div>
                <div class = "content2">
                    <h2>이항 연산(binary operation)</h2>
                    <p>
                        · 두 개의 항을 필요로하는 연산자이다. 예를 들어, 사칙 연산이 있다. <br>
                        · 두 개의 원소를 사용하여 새로운 원소를 만들어낸다.  
                    </p>
                    <h3 id = "binary-operation">이항 연산의 성질</h3>
                    <table class = "math-binary-operation">
                        <tr>
                            <th>성질</th>
                            <th>정의</th> 
                        </tr>
                        <tr>
                            <td>닫혀 있음</td>
                            <td>· 어떤 집합에서 두 원소를 사용한 이항 연산 결과는 항상 그 집합에 속한다. </td>
                        </tr>
                        <tr>
                            <td>교환 법칙</td>
                            <td>· 이항 연산에 사용되는 두 원소의 위치를 바꾸어도 결과가 동일하다. </td>
                        </tr>
                        <tr>
                            <td>결합 법칙</td>
                            <td>· 이항 연산에 사용되는 세 원소의 위치를 바꾸어도 결과가 동일하다. </td>
                        </tr>
                        <tr>
                            <td>분배 법칙</td>
                            <td>
                                · 두 이항 연산에 대해 a(b + c) = ab + ac, (b + c)a = ba + ca인 성질<br>
                                · 각각을 좌분배 법칙, 우분배 법칙이라고하며 두 가지 모두를 만족해야 분배법칙을 만족한다고 한다. 
                            </td>
                        </tr>
                        <tr>
                            <td id = "identity-source">항등원</td>
                            <td>· 'a (이항 연산자) b = a' 가 항상 성립하는 경우, 'b는 (이항 연산자)에 대한 항등원'이라고 한다. </td>
                        </tr>
                        <tr>
                            <td id = "inverse-element">역원</td>
                            <td>
                                · 'a (이항 연산자) b = (이항 연산자)에 대한 항등원' 이 항상 성립하는 경우, 'b는 (이항 연산자)에 대한 역원'이라고 한다. <br>
                                · 역원을 구하려면 항등원이 반드시 있어야만 한다. <br>
                                · 덧셈의 항등원은 0이므로, 덧셈의 역원은 -a이다. 역원은 항상 주어진 수에 -가 붙으므로 반대수(opposite number)라고도 한다. <br>
                                · 곱셈의 항등원은 1이므로, 곱셈의 역원은 1/a이다. 역원은 항상 주어진 수를 분수로 만드므로 역수(reciprocal)이라고도 한다. <br>
                            </td>
                        </tr>
                    </table>
                </div>
                <div class = "content2">
                    <h2>수와 집합</h2>
                    <h3>소박한 집합론(naive set theory)으로 수를 구분</h3>
                    <p>
                        (그림)
                        · 구분 가능한 '원소'로 수를 집합하는 것을 말한다. <br>
                        · 예를 들어, 자연수의 원소와 정수의 원소는 서로 구분지을 수 있으므로 집합으로 나타낼 수 있다. <br>
                        · 하지만 소박한 집합론은 인간의 언어로 보편적 관념에 의존하므로 일상생활에서 사용함은 문제없으나, 고차원적으로 수학의 체계를 세우고 다루기에는 정확하지 않다. 
                    </p>
                    <h3 id = "axiom-set-theory">공리적 집합론(axiomatic set theory)으로 수를 구분</h3>
                    <p>
                        · '연산'에 대한 공리로 수를 집합하는 것을 말한다. <br>
                        · 쉽게 말해 소박한 집합론에서의 '자연수', '정수', '실수' 처럼 특정한 수 집합을 지칭하는 단어가 있는 것이 아니라 <br>
                        · 수로 연산을 수행했을 때 연산이 가지는 성질만으로 수를 다루는 것이다. <br>
                        · 소박한 집합론과 달리 공리로 정확하게 수를 집합하므로 고차원적인 수 체계를 다루기에 적합하다. <br>
                        · 책에서는 <a href = "#binary-operation">🔗이항 연산의 성질</a>을 바탕으로 공리를 구축한다. 
                    </p>
                    <h3 id = "field">체(field)의 구조</h3>
                    <p>
                        · 수 집합의 두 수가 이항 연산을 수행함에 있어서 다음 11가지 조건을 확인해보자 <br>
                    </p>
                    <div class = "content3">
                        1. 연산에 대해 닫혀있다. <br>
                        2. 연산에 대해 교환 법칙이 성립한다. <br>
                        3. 연산에 대해 결합 법칙이 성립한다. <br>
                        4. 연산에 대한 항등원이 존재한다. <br>
                        5. 연산에 대한 역원이 존재한다. <br>
                        <span class = "emphasis">(이 다음은 임의의 이항 연산을 추가 해서 보자 (분배 법칙이 성립하는지 보기 위함))</span><br>
                        6. 두 번째 연산에 대해 닫혀 있다. <br>
                        7. 두 번째 연산에 대해 교환 법칙이 성립한다. <br>
                        8. 두 번째 연산에 대해 결합 법칙이 성립한다. <br>
                        9. 첫 번째 연산과 두 번째 연산에 대해 분배 법칙이 성립한다. <br>
                        10. 두 번째 연산에 대해 항등원이 존재한다. <br>
                        11. 두 번째 연산에 대해 역원이 존재한다. (단, 0은 제외)<br>
                    </div>
                    <br>
                    <p>
                        · 위의 공리를 모두 만족하는 '수 집합'을 체의 구조를 지닌다라고 한다. <br>
                        · 예를 들어, 유리수와 실수의 덧셈, 곱셈 연산은 위 공리를 모두 만족하여 체의 구조를 지닌다. <br>
                        · 이렇게 유리수와 실수처럼 체의 구조를 지니는 수 집합은 예외 없이 덧셈과 곱셈을 안전하고 자유롭게 쓸 수 있다. <br>
                        · 사칙 연산의 뺄셈, 나눗셈 연산은 교환법칙을 만족하지 않으므로 체의 구조를 지니지 않는다. <br>
                        · 뺄셈 대신 덧셈의 역원, 나눗셈 대신 곱셈의 역원을 사용하면 된다. <br>
                        · 정리하면 유리수 실수는 덧셈, 곱셈만에 체의 구조를 만족하므로 덧셈과 곱셈을 사용하자. <br>
                        (식)
                    </p>
                </div>
                <div class = "content2">
                    <h2>수의 표현</h2>
                    <h3 id = "number-line">수직선(number line)</h3>
                    <p>
                        · 실수(R)를 직선으로 표현한 것이다. <br>
                        · 직각으로 만나는 직선을 의미하는 수직선(perpendicular line)과 동음이의어이니 주의<br>
                        · 0을 기준으로 오른쪽은 양수 왼쪽은 음수이다. <br>
                        (그림)
                    </p>
                    <h5>절댓값(absolute value)</h5>
                    <p>
                        · 수가 원점으로부터 떨어진 거리이다. <br>
                        <div class = "equation-h5">$|a|$</div>
                    </p>
                </div>
                <div class = "content2">
                    <h2>함수(function)</h2>
                    <p>
                        (그림)<br>
                        · '두 집합'에서 첫 번째 집합의 원소가 두 번째 집합의 어떤 원소에 대응하는 관계
                    </p>
                    <h3>정의역(domain)</h3>
                    <p>
                        · 첫 번째 집합, 즉 함수에 대입할 값의 집합
                    </p>
                    <h3>공역(codomain)</h3>
                    <p>
                        · 두 번째 집합, 즉 함수에 값을 대입했을 때 나올 수 있는 모든 결과의 집합<br>
                        · 공역 co-domain... co-worker(동료)처럼, co 즉 같이 묶여 있다라는 느낌으로 이해하기. 
                    </p>
                    <h3>치역(range)</h3>
                    <p>
                        · 정의역의 원소에 대응되는 공역의 원소 집합, 즉, 공역 중 대입할 값을 넣었을 때의 결과 값(정의역과 대응되는 값)<br>
                        · 치역의 치는 値, 값 치자로 값의 영역으로 이해하면됨 즉, 정의역을 함수에 넣었을 때 나오는 값
                    </p>
                    <h3>함수의 성립 조건</h3>
                    <div class = "content3">
                        · 정의역의 모든 원소는 공역의 원소에 대응해야만 한다. (함수에 넣을 값은 반드시 유효한 값이다. )<br>
                        · 정의역의 원소 하나는 공역의 어느 한 원소에만 대응해야 한다. (함수에 값이 하나 들어갔는데 결과가 두 개 이상이 나오면 상식적으로 틀리다.)
                    </div>
                    <h3>전사 함수(全射: surjection, 위로의 함수(on to))</h3>
                    <!-- · 全(온전할 전(전부할때 전자))射(쏠 사(발사 할때 사))즉, 공역이 정의역 모두와 대응됨<br> -->
                    <div class = "content3">
                        · 공역의 원소와 정의역의 원소가 1:1대응 하는가? > <span class = "emphasis"> X </span><br>
                        · 공역의 모든 원소가 정의역과 대응하는가? (공역 = 치역인가? ) > <span class = "emphasis"> O </span><br>
                    </div>
                    <p>
                        · 全射, 즉, 공역의 모든 원소(全)가 정의역의 원소와 대응(射)되는 함수<br> 
                        (그림)
                    </p>
                    <h3>단사 함수(單射: injection, 일대일 함수(one-to-one))</h3>
                    <!-- · 單(홀로 단)射(쏠 사)즉, 공역이  -->
                    <div class = "content3">
                        · 공역의 원소와 정의역의 원소가 1:1대응 하는가? > <span class = "emphasis"> O </span><br>
                        · 공역의 모든 원소가 정의역과 대응하는가? (공역 = 치역인가? ) > <span class = "emphasis"> X </span><br>
                    </div>
                    <p>
                        · 單射, 즉, 공역의 원소 각각은  정의역 원소 각각(單)에만 대응되는 함수 즉, 1:1대응<br>
                        · 대응되지 않는 공역이 존재할 수 있음<br>
                        (그림)
                    </p>
                    <h3>전단사 함수(bijection, one-to-one and on to)</h3>
                    <div class = "content3">
                        · 공역의 원소와 정의역의 원소가 1:1대응 하는가? > <span class = "emphasis"> O </span><br>
                        · 공역의 모든 원소가 정의역과 대응하는가? (공역 = 치역인가? ) > <span class = "emphasis"> O </span><br>
                    </div>
                    <p>
                        · 전사 함수와 단사 함수의 조건을 모두 만족하는 함수<br>
                        · 공역과 정의역의 모든 요소가 빠짐없이 1:1 대응<br>
                        (그림)
                    </p>
                    <h3>합성 함수(function composition)</h3>
                    <p>
                        · 2개의 함수를 연쇄적으로 이어 하나의 함수로 만드는 연산 <br>
                        (식) <br>
                        · 합성함수를 이항 연산으로 규정하면 합성함수는 결합법칙이 성립한다. 
                        <h5> 합성 함수의 결합 법칙 증명</h5>
                    </p>
                    <h3>항등함수(identity function)</h3>
                    <p>
                        · 정의역과 공역이 '동일한 값'으로 대응되는 함수, 'id'로 표현한다. <br>
                        · 연산에서의 <a href = "#identity-source">🔗항등원</a>과 동일한 역할을 수행한다. <br>
                        · 즉, 합성함수 연산에서의 항등원 역할이라고 보면 된다. <br>
                        (그림)<br>
                    </p>
                    <div class = "equation-h3">
                        $id \circ f = f, f \circ id = f$
                    </div>
                    <h3>역함수(inverse function)</h3>
                    <p>
                        · 연산에서의 <a href = "#inverse-element">🔗역원</a>과 동일한 역할을 수행한다. <br>
                        · 즉, 합성함수 연산에서의 역원 역할이라고 보면 된다. <br>
                        · 반드시 전단사 함수만 역함수가 될 수 있음에 주의! <br>
                        <div class = "equation-h3">
                            $f^{-1} \circ f = id, f \circ f^{-1} = id$
                        </div>
                    </p>
                    <h3>곱집합(cartesian product)</h3>
                    <p>
                        · 두 집합이 있을 때, 그 두 집합의 원소를 순서쌍으로 묶은 원소의 집합<br>
                        · 곱집합은 순서쌍의 요소를 수직으로 배치하는 성질이 있다. <br>
                        · 이 성질을 때문에 두 실수 집합을 곱집합으로 나타내면 좌표 평면을 만들 수 있다. 
                    </p>
                </div>
                <div class = "content2">
                    <h2>데카트르 좌표계(cartesian coordinate system)</h2>
                    <p>
                        · 이렇게 두 실수 집합의 곱집합으로 만들어진 좌표 평면 즉, 평면 공간을 데카르트 좌표계라고 한다. <br>
                        · 곱집합의 원어가 데카르트 곱(cartesian product)임을 생각해보면 둘은 동일한 개념이다. <br>
                        · 공리적 집합론으로 규정하기 때문에 데카르트 좌표계의 두 수 집합을 실수 집합이라 하지 않고 체의 구조를 지니는 수 집합이라고 한다. <br>
                    </p>
                    <h3>사분면</h3>
                    <p>
                        · 데카르트 좌표계는 2개의 수직선이 원점(0, 0)에서 접하여 수직으로 배치되어 나뉘어있고 4개의 면을 가진다. <br>
                        · 각각의 면을 시계 반대 방향 순서로 제1사분면, 제2사분면, 제3사분면, 제4사분면이라고 한다. 
                    </p>
                    <h3>좌표(coordinate)</h3>
                    <p>
                        · 데카르트 좌표계 상의 원소는 곱집합과 같이 순서쌍으로 표현하며 좌표라고 한다. <br>
                        · <a href = "#number-line">🔗수직선(number line)</a>에서와 동일하게 점 또는 원점으로 부터의 화살표로 표현한다. <br>
                        (그림)<br>
                        · 즉 수직선 -> 평면으로 바뀌었을 뿐 수직선에서 수를 다루는 방식과 매우 유사하다. <br>
                    </p>
                    <h3>벡터 공간(vector space)</h3>
                    <p>
                        · 두 개 이상의 실수를 곱집합으로 묶어 형성된 집합을 <a href = "#axiom-set-theory">🔗공리적 집합론</a>으로 규정하면 벡터 공간(vector space)라고 한다. <br>
                        · 수직선(1차원)에서의 점의 이동처럼 평면 좌표(2차원)에서의 이동을 위해서는 새로운 연산을 고안해야한다. <br>
                        · 데카르트 좌표계는 두 실수의 집합이므로 실수가 지니는 연산의 성질(공리적 집합론)을 바탕으로 연산을 설계해야한다. <br>
                        · 데카르트 좌표계는 두 실수 집합이고, 실수 연산은 <a href = "#field">🔗체(field)의 구조</a>를 지닌다. 
                    </p>
                    <h5>벡터(vector)</h5>
                    <p>
                        · 벡터 공간에서의 원소
                    </p>
                    <h5>벡터의 크기(= 노름(Norm))</h5>
                    <p>
                        · 원점으로부터의 최단거리이다. <br>
                        · 즉, 벡터의 크기는 벡터의 길이이다. <br>
                        · 원점과 벡터를 연결하여 최단거리를 만든 후 직각삼각형을 그려 피타고라스 정리를 사용하여 구한다. <br>
                    </p>
                    <div class = "equation-h5">
                        $|\vec{v}|=||\vec{v}||=\sqrt{a^{2}+b^{2}}$
                    </div>
                    <h5>단위 벡터(unit vector)</h5>
                    <p>
                        · 크기가 1인 벡터이다. <br>
                        · $\hat{v}$는 $\vec{v}$를 단위 벡터로 표현한 것이다. 기호 $\hat{}$ 은 'hat'(모자 같이 생겨서)이라고 읽는다. <br>
                        · 단위 벡터는 벡터 / 벡터 크기이다. <br>
                        · <a href = "#vector-operation">🔗벡터 공간에서의 스칼라 곱셈의 성질</a>을 이용해 임의의 벡터 v를 벡터 v의 크기로 나누면 된다. <br>
                        · 벡터를 단위벡터로 만드는 작업을 정규화(normalize)라고 한다. 
                    </p>
                    <div class = "equation-h5">
                            $\hat{v} = \frac{\vec{v}} {|\vec{v}|}$
                    </div>
                    <h5>스칼라(scalar)</h5>
                    <p>
                        · 체의 구조를 지니는 수 집합의 원소 <br>
                        · 벡터 공간의 두 실수 x, y각각 공리적 집합론의 관점에서 '체 집합의 원소'라고 함 즉, 스칼라임 <br>
                        (그림)
                    </p>
                    <h3 id = "vector-operation">벡터 공간의 연산</h3>
                    <p>
                        · 체가 갖는 연산의 성질에 기반하여 벡터 공간의 연산이 갖는 성질을 아래 표로 정리하였다. <br>
                        · 이를 벡터 공간의 8가지 공리라고한다. 
                    </p>
                    <table class = "math-vector-space">
                        <tr>
                            <th>분류</th>
                            <th>공리</th>
                            <th>수식</th>
                        </tr>
                        <tr>
                            <td rowspan = 4>벡터의 합</td>
                            <td>벡터 합의 결합 법칙</td>
                            <td>$\vec{u}+(\vec{v}+\vec{w})=(\vec{u}+\vec{v})+\vec{w}$</td>
                        </tr>
                        <tr>
                            <td>벡터 합의 교환법칙</td>
                            <td>$\vec{u}+\vec{v}=\vec{v}+\vec{u}$</td>
                        </tr>
                        <tr>
                            <td>벡터 합의 항등원</td>
                            <td>$\vec{v}+\vec{0}=\vec{v}$</td>
                        </tr>
                        <tr>
                            <td>벡터 합의 역원</td>
                            <td>$\vec{v}+(-\vec{v})=\vec{0}$</td>
                        </tr>
                        <tr>
                            <td rowspan = 4>스칼라 곱셈</td>
                            <td>스칼라 곱셈의 호환성</td>
                            <td>$a(b\vec{v})=(ab)\vec{v}$</td>
                        </tr>
                        <tr>
                            <td>스칼라 곱셈의 항등원</td>
                            <td>$1·\vec{v}=\vec{v}$</td>
                        </tr>
                        <tr>
                            <td>벡터의 합에 대한 분배 법칙</td>
                            <td>$a(\vec{u}+\vec{v})=a\vec{u}+a\vec{v}$</td>
                        </tr>
                        <tr>
                            <td>스칼라 덧셈에 대한 분배법칙</td>
                            <td>$(a+b)\vec{v}=a\vec{v}+b\vec{v}$</td>
                        </tr>
                        
                    </table>
                </div>
                <div class = "content2">
                    <h2>선형 결합식과 선형 종속과 선형 독립</h2>
                    <h3>선형 결합식</h3>
                    <p>
                        · n개의 스칼라와 벡터를 결합하여 새로운 벡터를 생성하는 수식을 말한다. <br>
                        · 선형 종속, 선형 독립을 알아볼 때에는 선형 결합의 결과가 $\vec{0}$즉, 영벡터인 경우를 사용한다. <br>
                    </p>
                    <div class = "equation-h3">
                        $a_{1}\vec{v_{1}} + a_{2}\vec{v_{2}} + a_{3}\vec{v_{3}} + ··· + a_{n}\vec{v_{n}} = \vec{v^{'}}$
                    </div>
                    <p>
                        · 벡터가 선형 종속인지 독립인지 확인하려면 다음 식이 필요하다. 
                    </p>
                    <div class = "equation-h3">
                        $a_{1}\vec{v_{1}} + a_{2}\vec{v_{2}} + a_{3}\vec{v_{3}} + ··· + a_{n}\vec{v_{n}} = \vec{0}$
                    </div>
                    <h3>선형 종속</h3>
                    <p>
                        · 선형 결합식의 결과가 $\vec{0}$ 일 때, 스칼라가 0이 아니어도(즉 0인 경우 포함) 영벡터가 나올수 있다면, 선형 결합식에 있는 벡터들은 선형 종속 관계라고 한다. <br>
                        · 즉 n개의 벡터가 서로 같은 선 상에 놓여진 상태이다. 
                        <div class = "equation-h3">예: $2 · (1, 2) + -1 · (2, 4) = \vec{0}$</div>
                    </p>
                    <h3>선형 독립</h3>
                    <p>
                        · 선형 결합식의 결과가 $\vec{0}$ 일 때, 스칼라가 0이어야만 영 벡터가 나올 수 있다면, 선형 결합식에 있는 벡터들은 선형 독립 관계 라고 한다. <br>
                        · 즉, n개의 벡터가 모두 다른 선 상에 놓여진 상태이다. <br>
                        · 선형 독립 관계를 가지는 벡터들로는 2차원 벡터 공간 상의 모든 벡터를 생성할 수 있다. <br>
                        · 선형 독립 관계는 2개의 벡터만이 가질 수 있다. 
                        <div class = "equation-h3">$0 · \vec{v_{1}} + 0 · \vec{v_{2}} = \vec{0}$</div>
                    </p>
                    <h5>선형 독립에 2개의 벡터만 사용되는 이유 증명</h5>
                    <div class = "equation-h5">
                        우선 2개의 벡터만 사용되어야하는 이유를 알아보기 위해 선형 독립 관계인 3개의 벡터를 선형 결합하는 식을 살펴보자. <br>
                        <br>
                        $a\vec{v_{1}} + b\vec{v_{2}} + c\vec{v_{3}} = \vec{0}$ <br>
                        <br>
                        3개의 백터가 모두 선형 독립 관계를 가지려면 스칼라 $a$, $b$, $c$는 모두 0이어야한다. 
                        <br>
                        이제 앞에서 두 번째 까지의 항을 선형 결합해보자. 두 항은 선형 독립 관계 이므로, 위 식의 끝 항에 $-1$을 곱한 $-c\vec{v_{3}}$도 생성 가능하다. <br>
                        <br>
                        $-c\vec{v_{3}} + c\vec{v_{3}} = \vec{0}$<br>
                        <br>
                        이 경우 스칼라 $c$가 0이어도 성립하지만, 0이 아니어도 위 선형 결합식이 성립한다. <br>
                        즉, 스칼라 $c$가 0이 아닌 경우는 선형 종속 관계에 해당하여 선형 독립 관계를 만족하지 못한다. <br>
                        따라서, 선형 독립 관계여야한다면 반드시 2개의 벡터여야 하고<br>
                        반드시 2개의 벡터여야만 2차원 벡터 상의 모든 벡터를 생성 가능하다. 
                    </div>
                    <h5>기저(Basis)</h5>
                    <p>
                        · 선형 독립 관계를 가지는 벡터들의 집합<br>
                    </p>
                    <div class = "equation-h5">
                        $(2, 1), (1, 3)$로 이루어진 집합은 기저이다. 
                    </div>
                    <h5>기저 벡터(Basis Vector)</h5>
                    <p>
                        · 기저(Basis)에 속한 벡터 원소들 각각 <br>
                        · 기저의 원소가 1개면 1차원, 2개면 2차원, 3개면 3차원 ··· n개면 n차원 <br>
                        · 기저 벡터를 다른 값으로 변경하면 기저벡터로 부터 세워진 벡터 공간의 모든 원소가 바뀐다. 이는 선형 변환의 기본 원리가 된다. <br>
                    </p>
                    <div class = "equation-h5">
                        $(2, 1), (1, 3)$에서 $(2, 1)$과 $(1, 3)$각각을 기저 벡터라고 한다. 
                    </div>
                    <h5>표준 기저(standard basis)</h5>
                    <p>
                        · 기저의 원소가 중 단위 벡터만 원소로 구성된 것<br>
                    </p>
                    <div class = "equation-h5">
                        $R^{2}$ 튜플 상 $(1, 0), (0, 1)$은 표준 기저이다. <br>
                        $R^{3}$ 튜플 상 $(1, 0, 0), (0, 1, 0), (0, 0, 1)$은 표준 기저이다.  
                    </div>
                </div>
                <!-- <div class = "content2">
                    <h2>삼각 함수(trigonometric function)</h2>
                    <h3>삼각비(trigonometric ration)</h3>
                    <figure><img src = "../img/Trigonometry_triangle.png"><figcaption>출처: https://ko.wikipedia.org/wiki/%EC%82%BC%EA%B0%81%ED%95%A8%EC%88%98</figcaption></figure><br>
                    <p>
                        · 직각 삼각형을 구성한는 세 변에서 두 변을 뽑아 각각의 비례관계를 나타낸 것. <br>
                        · $\angle A$는 사잇각이다. θ(세타)라고 하자, 사잇각은 0˚ 초과, 90˚ 미만의 값이어야만 한다. <br>
                        · hypotenuse(빗변), opposite(높이), adjacent(밑변)이 있고 직각삼각형을 밑변이 바닥에 닿도록 세운 상태로 둬보자. <br>
                        · 그 경우 다음과 같은 삼각비가 형성된다. 
                    </p>
                    <div class = "equation-h3">
                        $sinθ = \frac {a} {h}$ <br>
                        $cosθ = \frac {b} {h}$ <br>
                        $tanθ = \frac {a} {b}$
                    </div>
                    <h3>삼각 함수(trigonometric function)</h3>
                    <figure><img src = "../img/trigonometric-function.png"><figcaption>출처: https://ko.wikipedia.org/wiki/%EC%82%BC%EA%B0%81%ED%95%A8%EC%88%98#/media/%ED%8C%8C%EC%9D%BC:Circle-trig6.svg</figcaption></figure><br>
                    <p>
                        · 이제 이 직각 삼각형을 데카르트 좌표계에 배치하고 $\angle A$ θ(세타)의 범위를 실수 전체로 확장하자 이것을 삼각함수(trigonometric function)라고 한다. <br>
                        · 삼각함수는 직각삼각형에서 출발했지만 반지름의 길이가 1인 단위 원(unit circle)을 사용하면 쉽게 표현할 수 있다. <br>
                        · 단위 원은 반지름이 1이므로 단위원 속의 직각 삼각형의 빗변의 길이 $h$ 는 1이다. 
                    </p>
                    <h5>원주율(pi)</h5>
                    <p>
                        · 원의 지름이 1일 때 그 둘레의 길이가 약 3.141592라는 뜻이다. (1cm면 약 3.141592cm, 1m이면 약 3.141592m...) <br>
                        · 즉, 원의 지름에 대한 원주(원 둘레)의 비율 약 3.141592...이다. 순환하지 않는 무한 소수이며 π(파이)로 나타낸다. <br>
                        · 원주율을 활용하면, 원의 둘레의 길이를 구하기 위해 일일히 줄자로 잴 필요 없이 그 원의 지름의 길이를 원주율로 곱하면 된다. 
                    </p>
                    <h5>각도법(degree)</h5>
                    <p>
                        · 0˚ ~ 360˚로 각도를 나타내는 방법 <br>
                        · 각도법은 360이라는 큰 수를 사용하고 약수가 많은 수라 수를 잘 나누어 일상 생활에서 다양하게 쓰도록 만든 것이다. <br>
                    </p>
                    <h5>호도법(radian)</h5>
                    <figure><img src = "../img/radian.png"><figcaption>출처: https://namu.wiki/jump/RhXB9%2BU1Zy4FkTm13Rsg%2BLEB8eTMkOzuD8HLoEcYIXi6D0pJJDxjFywrb5msiEqACph1VFKqT0xaaybkFGQaaH73P6prTs%2FKb3v4bOXBzLzUdYOMgQV1gpHUcX%2FJ4sgN</figcaption></figure>
                    <h5></h5>
                    <p>
                        · 반지름의 길이가 r인 원의 호의 길이가 r이 되는 경우의 중심각이 기준이다. 이를 '1라디안'( $1(rad)$ )이라고 한다. <br>
                        
                    </p>
                    <div class = "equation-h5">
                        반지름 r인 원, 특정 각에 대한 호의 길이를 l이라하면<br>
                        원주율에 의해 (원주율은 모든 원에 대해 일정하므로) <br>
                        <br>
                        $\frac {l} {r}$ <br>
                        <br>
                        이 성립한다. 
                    </div>
                    <h5></h5>
                    <p>
                        · 벡터가 단위량인 1을 기준으로한 단위벡터를 정의한 것처럼 각도도 이렇게 하면 편할 것이다. <br>
                        · 지름이 1인 원의 원주는 $2πr$ 중심각은 $360˚$이므로 다음이 성립한다. 
                    </p>
                    <div class = "equation-h5">
                        $360˚ = 2π(rad)$<br>
                        $180˚ = π(rad)$ <br>
                        <br>
                        $1(rad) = \frac{180˚} {π}$<br>
                        $1˚ = \frac{π} {180˚}(rad)$ <br>
                    </div>
                    <h5>sin 함수</h5>
                    <h5>cos 함수</h5>
                    <h5>회전과 관련된 계산에 유용한 공식</h5>
                    <p>
                        · 단위 원에서 반지름 선상에 위치한 모든 점의 좌표는 $(cosθ, sinθ)$로 각 θ(세타)에 의해 결정된다. <br>
                        ·
                    </p>
                    <div class = "equation-h5">
                        $cos^{2}θ + sin^{2}θ = 1$
                    </div>
                    <h5>회전과 관련된 계산에 유용한 공식 증명</h5>
                
                    <h5>삼각함수를 사용한 물체의 회전 구현</h5>
                </div> -->
                <div class = "content2">
                    <h2>4장 삼각함수: 회전을 위한 수학</h2>
                    <p>
                        · 회전은 원의 궤적을 따라 움직이는 이동을 정의하는 것이라서 원과 밀접한 연관이 있는 삼각함수를 알아야한다. 
                    </p>
                    <h3>삼각함수</h3>
                    <figure><img src = "../img/Trigonometry_triangle.png"><figcaption>출처: https://ko.wikipedia.org/wiki/%EC%82%BC%EA%B0%81%ED%95%A8%EC%88%98</figcaption></figure><br>
                    <p>
                        · 삼각함수를 보기 전에 <span class = "keyword">삼각비(trigonometric ratio)</span>를 보면, 삼각비란 직각 삼각형을 구성한는 세 변에서 두 변을 뽑아 각각의 비례관계를 나타낸 것. <br>
                        · $\angle A$는 사잇각이다. θ(세타)라고 하자, 사잇각은 0˚ 초과, 90˚ 미만의 값이어야만 한다. <br>
                        · hypotenuse(빗변), opposite(높이), adjacent(밑변)이 있고 직각삼각형을 밑변이 바닥에 닿도록 세운 상태로 둬보자. <br>
                        · 그 경우 다음과 같은 삼각비가 형성된다. 
                        <div class = "equation-h3">
                            $sinθ = \frac {a} {h}$ <br>
                            $cosθ = \frac {b} {h}$ <br>
                            $tanθ = \frac {a} {b}$
                        </div><br>
                    </p>
                    <figure><img src = "../img/noradial.jpg" width="50%" id="no-radial"><figcaption>출처: 이득우의 게임 수학(이득우 저) p.118</figcaption></figure>
                    <p>
                        · 이제 삼각함수를 알아보자, 삼각비의 사잇각$\angle A$의 범위를 실수 전체(집합R)로 확장한 대응 관계를 <span class = "keyword">삼각함수(trigonometric function)</span>라고 한다. <br>
                        · 사잇각의 범위가 실수 전체가 되었으므로 직각삼각형이 아니라 데카르트 좌표계 상 원점을 중점으로 하는 반지름 $r$이 1인 단위원 상에서 생각하는 것이 알맞다. <br>
                        · 위 사진에서 r이 1일때 피타고라스 정리에 의해 아래의 식이 성립한다. <br>
                        · 아래의 식은 삼각함수의 기본을 다루는데 중요한 공식이고, 회전 관련 계산에 유용하므로 숙지하도록 한다. 
                    </p>
                    <div class = "equation-h3">
                        단위 원의 반지름을 빗변으로 하는 직각 삼각형은 삼각비에 의해<br>
                        <br>
                        밑변의 길이가 $cosθ$ <br>
                        높이가 $sinθ$가 된다. <br>
                        <br>
                        이것을 피타고라스 정리 $a^{2}+b^{2}=c^{2}$ 에 대입하면 다음과 같다. <br>
                        <br>
                        $cos^{2}θ + sin^{2}θ = 1$ <span class = "formula">식 1</span><br> 
                        <br>
                        이는 단위원이 아닌 경우도 성립한다. 확인해보자<br>
                        <br>
                        <br>
                        반지름을 r로 두면<br>
                        빗변의 길이는 r이 된다. <br>
                        이는 벡터 개념으로 보면 길이가 1인 벡터와 평행하고 길이가 r배만큼 증가한 것이다. <br>
                        <br>
                        따라서,<br>
                        밑변의 길이는  $r · cosθ$ <br>
                        높이는 $r · sinθ$ 가 된다. <br>
                        <br>
                        이것을 피타고라스 정리에 대입하면 다음과 같다. <br>
                        <br>
                        $r^{2}cosθ^{2} + r^{2}sinθ^{2} = r^{2}$ <br>
                        $cos^{2}θ + sin^{2}θ = 1$ <br>
                        <br>
                        결국 반지름$r$과 상관 없이 <span class = "formula">식 1</span> 이 성립한다. 
                    </div><br>
                    <h5>삼각함수의 성질</h5>
                    <figure><img src = "../img/cossin.jpg" width="50%"><figcaption>출처: 이득우의 게임 수학(이득우 저) p.120</figcaption></figure>
                    <h5></h5>
                    <p>
                        · 데카르트 좌표계에서 <span class = "keyword">각도(degree)</span>란 x축에서 원의 궤적을 따라 반시계 방향으로 회전한 크기를 의미한다. <br>
                        · 반지름이 1인 단위원상에서 반시계 방향으로의 회전을 생각해보자. <br>
                        · 각 세타의 범위에 따른 $cosθ$, $sinθ$, $tanθ$의 값을 그래프의 형태로 나타내면 위의 사진과 같아진다. <br>
                        · 그래프에서 변화하는 '값'의 범위를 <span class = "keyword">진폭(amplitude)</span>라고 한다. <br>
                        · 진폭이 반복되는 범위를 <span class = "keyword">주기(period)</span>라고 한다. <br>
                        · $sin$ 함수와 $cos$ 함수는 항상 -1 ~ 1사이의 진폭을 가진다. <br>
                        · $sin$ 함수와 $cos$ 함수는 360˚ 주기로 반복된다. <br>
                        · $sin$ 함수는 원점 대칭 함수로 홀함수 또는 <span class = "keyword">기함수</span>라고 한다. <br>
                        · $cos$ 함수는 y축 대칭 함수로 짝함수 혹은 <span class = "keyword">우함수</span>라고 한다. <br>
                        · $sin$ 함수와 $cos$함수의 특성으로 인해 아래의 공식이 성립한다. 향후 회전 관련 계산에 유용하므로 숙지하자. 
                    </p>
                    <div class = "equation-h5">
                        <span class = "keyword" id = go-100>삼각 함수의 성질</span>은 아래와 같다. <br>
                        <br>
                        $cos$ 함수는 우함수이므로 다음이 성립한다. <br>
                        <br>
                        $cos(θ)=cos(-θ)$<br>
                        <br>
                        $sin$ 함수는 기함수이므로 다음이 성립한다. <br>
                        <br>
                        $sin(-θ)=-sin(θ)$
                    </div>
                    <h5></h5>
                    <p>
                        · tan 함수는 빗변과 무관하게 밑변과 높이의 관계만을 나타낸다. <br>
                        · sin, cos 함수와 같이 tan함수도 단위원 상에서 보면 아래의 공식이 성립한다. <br>
                    </p>
                    <div class = "equation-h5">
                        삼각비에 의하면, 밑변 / 높이 = $tanθ$이므로<br>
                        <br>
                        $\tanθ = \frac{\frac{b} {c}} {\frac{a} {c}} = \frac{sinθ} {cosθ}$<br>
                        <br>
                        분모는 0이 될 수 없으므로,<br>
                        $cos$ 함수에서 값이 0인 -270˚, -90˚, 90˚, 270˚에서는 $tan$ 함수의 값이 존재하지 않는다.
                        <figure><img src = "../img/tan.jpg" width="50%"><figcaption>출처: 이득우의 게임 수학(이득우 저) p.121</figcaption></figure><br>
                    </div>
                    <h5>각의 측정법</h5>
                    <p>
                        · <span class = "keyword">각도법(degree)</span>과 <span class = "keyword">호도법(radian)</span>이 있다. <br>
                        · <span class = "keyword">각도법(degree)</span>은 0 ~ 360까지의 수를 사용하여 각을 표현한다. 360은 약수가 많은 수여서 다양한 방법으로 원의 각을 쪼개어 나타낼 수 있다. <br>
                        · 하지만 360이라는 수는 큰 수이므로 실무 계산에서는 호도법을 주로 사용한다. <br>
                        · <span class = "keyword">호도법(radian)</span>은 호의 길이가 원의 반지름과 같아질 때의 사잇각을 기준으로 나타낸다. <br>
                        · 즉 호의 길이를 각도로 표현하는 것이다. <br>
                        · 호도법은 따로 각도를 나타내는 기호가 존재하지 않는다. <br>
                        · 호도법으로 각을 나타내는 방법은 아래와 같다. 
                    </p>
                    <div class = "equation-h5" style = "text-align: left;">
                        원주율을 사용하여 원의 지름을 구하는 공식을 생각해보자 <br>
                        '원주율 * 지름'이 원주이므로 '2* 원주율 * 반지름'도 원주이다. <br>
                        원주 공식과 각도법를 대응시켜 호도법을 나타낸다면 다음과 같은 식이 성립한다. <br>
                        <br>
                        $360˚r = 2πr(rad)$<br>
                        <br>
                        위 식을 간단히 해보자 <br>
                        <br>
                        $180˚r = πr(rad)$ 
                        <br>
                        $1˚ = \frac{π} {180˚}(rad)$ <span class = "formula">식 1</span><br>
                        $(\frac{180} {π})˚ = 1(rad) (\approx 57.2958˚)$<br>
                        <br>
                        <span class = "formula">식 1</span>을 사용하여 원하는 각도를 곱하면 라디안을 얻을 수 있다. 
                    </div>
                    <h3>삼각 함수를 활용한 물체의 회전</h3>
                    <p>
                        · 벡터를 늘이는 것은 x축과 y축이 서로 독립적으로 적용된다. 따라서 따로 계산한 후 두 결과를 결합하면 된다. <br>
                        · 하지만 회전동작은 x, y축이 동시에 영향을 받기 때문에 독립적으로 계산이 불가능하다. <br>
                        · 회전을 어떻게 계산하는지 알아보자. <br>
                    </p>
                    <div class = "equation-h3">
                        우선 실 벡터 공간 $\mathbb{R}^2$를 회전시켜보자. <br>
                        실 벡터 공간 $\mathbb{R}^2$는 표준 기저 벡터 $e_{1}, e_{2}$를 기저로 두고 있다. <br>
                        그리고 표준 기저 벡터를 선형 결합하여 실 벡터 공간 $\mathbb{R}^2$상에 모든 벡터를 표현할 수 있다. <br>
                        <br>
                        우선 표준 기저 벡터 $e_{1}=(1, 0)$을 θ만큼 회전시킨 것 $e'_{1}$은 앞서 학습한 것과 같이. <br>
                        <br>
                        $e'_{1}=(cosθ, sinθ)$ 이다. <br>
                        <br>
                        다음, 표준 기저 벡터 $e_{2}$을 θ만큼 회전시킨 것 $e'_{2}$는 $e_{1}$을 통해서 추론할 수 있다. <br>
                        <br>
                        $e_{1}=(1, 0)$<br>
                        $e'_{1}=(cosθ, sinθ)$<br>
                        <br>
                        $e_{2}=(0, 1)$<br>
                        $e'_{2}=(-sinθ, cosθ)$<br>
                        <br>
                        기저를 회전 시키면 실 벡터 공간이 회전 된 것과 같다. <br>
                        왜냐하면 벡터 공간의 기저를 통해 선형 결합식을 사용하여 다른 모든 벡터들을 생성하기 때문이다. <br>
                        정리하면, 실 벡터 공간 $\mathbb{R}^2$ 자체를 회전한 결과는 다음과 같다. <br>
                        <br>
                        $e'_{1}=(cosθ, sinθ)$<br>
                        $e'_{2}=(-sinθ, cosθ)$<br>
                        <br>
                        이제, 실 벡터 공간 $\mathbb{R}^2$의 θ만큼 회전 변환된 기저를 사용하여 특정 벡터를 생성해보자. <br>
                        선형 결합식을 사용하여 임의의 벡터 $\vec{v}=(x,y)$를 회전한 결과 $\vec{v'}=(x', y')$는 다음과 같다. <br>
                        <br>
                        $\vec{v'}=xe'_{1}+ye'_{2}=x(cosθ, sinθ) + y(-sinθ, cosθ)=(xcosθ-ysinθ, xsinθ+ycosθ)$<br>
                        <br>
                        $x_{'}=xcosθ-ysinθ$<br>
                        $y_{'}=xsinθ+ycosθ$
                    </div>
                    <h3>삼각함수의 역함수</h3>
                    <p>
                        · 삼각 함수를 이용하여 각도를 사용해 좌표를 구하였다면 그 반대로 좌표에서 각도를 구할 수 있다. <br>
                        · 이는 삼각함수의 역함수를 사용하여 구한다. <br>
                    </p>
                    <div class = "equation-h3">
                        우선$sin$함수의 역함수 $arcsin$함수를 구하기 위해(역함수는 전단사 함수만 가능하므로) 삼각함수에서 전단사함수가 되도록 정의역의 범위를 제한하면<br>
                        [-90˚, 90˚]구간이 정의역 구간이 된다. 이 경우 전단사 함수가 성립하므로 역함수를 구하면 다음과 같다. <br>
                        <br>
                        (그래프 p.141)<br>
                        $f^{-1}(x)=sin^{-1}(x)=arcsin(x)$<br>
                        <br>
                        $cos$함수의 역함수도 동일하게 전단사함수가 되도록 정의역을 제한하면 <br>
                        [0˚, 180˚]구간이 정의역 구간이 된다. <br>
                        <br>
                        (그래프 p.142)<br>
                        $f^{-1}(x)=cos^{-1}(x)=arccos(x)$<br>
                        <br>
                        $tan$함수는 정의역이 존재하지 않는 구간이 존재한다<br>
                        따라서, 이를 고려하여 역함수를 설계한다. <br>
                        $tan$함수의 역함수는 (-90˚, 90˚)구간이 정의역 구간이 된다. <br>
                        <br>
                        (그래프 143)<br>
                        $f^{-1}(x)=tan^{-1}(x)=arctan(x)$<br>
                        <br>
                        arcsin함수는 정의역이[-90˚, 90˚]구간이므로 이 구간에서만 치역이 존재한다. <br>
                        arcsin함수는 정의역이[0˚, 180˚]구간이므로 이 구간에서만 치역이 존재한다. <br>
                        arctan함수는 정의역이(-90˚, 90˚)구간이므로 이 구간에서만 치역이 존재한다. <br>
                        <br>$sin, cos, tan$함수의 역함수를 구해본 결과를 보기 쉽게 정리하면 아래와 같다. <br>
                        <br>
                        $sin(θ) = y$이므로 역함수는 $arcsin(y) = θ$ (단, y는 [-90˚, 90˚])<br>
                        $cos(θ) = x$이므로 역함수는 $arccos(x) = θ$ (단, x는 [0˚, 180˚])<br>
                        $tan(θ) = \frac{y} {x}$이므로 역함수는 $arctan(\frac{y} {x}) = θ$ (단, $\frac{y} {x}$는 (-90˚, 90˚))<br>
                        <br>
                        각각의 역함수의 치역 범위를 이를 데카르트 좌표계상에 나타내면 3사분면의 정보는 알 수가 없다. <br>
                        3사분면에 있는 임의의 벡터$\vec{v}=(x,y)$의 각도를 arctan함수로 구해보자<br>
                        <br>
                        $\vec{v}=(x,y)$에서 x와 y는 음수이다. <br>
                        둘 다 음수이기 때문에 분수값을 arctan에 넣으면 양수가 되므로 1사분면에 해당하는 각의 정보가 나온다. <br>
                        <br>
                        (그림 145)<br>
                        <br>
                        이 경우는, x, y를 따로 전달하여 그 부호를 파악한 후 벡터가 1사분면에 있는지 3사분면에 있는지 파악할 수 있는 $atan2$함수가 있다.<br>
                        <a href = "https://www.ibm.com/docs/ko/i/7.3?topic=functions-atan-atan2-calculate-arctangent" target = "_blank">🔗IBM: atan()-atan2()-역탄젠트 계산</a>
                        <br>
                        $atan2(y, x)$<br>
                        <br>
                        $atan2$ 함수는 (-180˚, 180˚)의 공역 범위를 가진다. <br>
                        <br>
                        (그림 146)
                    </div>
                    <h3>극좌표계(polar coordinate system)</h3>
                    <p>
                        · 회전할 때마다 매번 x, y의 변화를 계산하는 것은 번거로운데, <br>
                        · 이 번거로움을 해결하기 위해, 회전 기반으로 설계된 좌표계이다. <br>
                        · 극 좌표계는 원점으로부터의 거리 r과 θ로 구성된다. <br>
                    </p>
                    <div class = equation-h3>
                        디카르트 좌표계인 벡터 $\vec{v}=(x,y)$를 극좌표계로 변환해보자. <br>
                        <br>
                        극좌표계 r은 원점으로 부터의 거리이므로 직각 삼각형의 빗변에 대응된다. 따라서 피타고라스 정리로 구할 수 있다. <br>
                        <br>
                        $r^{2}=x^{2}+y^{2}$<br>
                        $r=\sqrt{x^{2}+y^{2}}$<br>
                        <br>
                        극좌표계 θ는 중심각이므로 앞서 배운 atan2함수로 구할 수 있다. <br>
                        <br>
                        $θ=atan2(y, x)$<br>
                        <br>
                        정리하면, 임의의 벡터 $\vec{v}$에서 극좌표계로의 변환은 다음과 같다. <br>
                        <br>
                        $r=\sqrt{x^{2}+y^{2}}$<br>
                        $θ=atan2(y, x)$<br>
                    </div>
                    <div class = "equation-h3">
                        반대로 극좌표계를 데카르트 좌표계로 변환해보자. 극좌표계$(r, θ)$를 보자 <br>
                        <br>
                        r은 결국 원의 반지름 길이, θ는 단위원 상의 중심각과 같으므로<br>
                        삼각함수를 사용하여 변환할 수 있다. <br>
                        <a href = "#no-radial">🔗삼각함수와 좌표 이미지</a>
                        <br>
                        $x = r·cosθ$<br>
                        $y = r·sinθ$<br>
                    </div>
                </div>
                <div class = "content2">
                    <h2>5장 행렬: 가상 세계의 변환 도구</h2>
                    <h3>선형성: 예측 가능한 비례 관계</h3>
                    <p>
                        · 선형성은 직선으로 쭉 뻗은 진선의 형태를 의미한다. <br>
                        · 수학에서 명확함을 위해 선형성을 참 거짓을 명확히 해주는 명제로 나타내면 다음과 같다. <br>
                    </p>
                    <div class = "equation-h3" style = "text-align:left">
                        가법성: $f(x_{1} + x_{2}) = f(x_{1}) + f(x_{2})$<br>
                        <br>
                        1차 동차성: $f(kx) = kf(x)$<br>
                        을 만족하면 선형성을 지닌다고 한다. 
                    </div>
                    <h5>선형 함수</h5>
                    <p>
                        · 1차 동차성, 가법성을 모두 만족하는 선형 함수는 아래 뿐이다. 
                    </p>
                    <div class = "equation-h5">
                        $y = ax$
                    </div>
                    <h5></h5>
                    <p>
                        · 즉, 선형 함수는 원점을 반드시 지나야만 한다. <br>
                        · $y = ax + b$의 경우 선형적으로 생겼으나 가법성을 만족하지 못한다. 따라서 선형 함수가 아니다. <br>
                        · 직선의 형태를 띰에도 선형성을 만족하지 못하는 이유는 선형성은 단지 곧게 뻗은 직선을 의미하는 것이 아니다. <br>
                        · 선형성은 순수비(ratio)여야 한다. 따라서 어떤 값을 대입했을 때 쉽게 출력값을 알 수 있어야하고, <br>
                        · 역함수 $y = \frac{1} {a}x$를 사용하여 출력값으로 부터 쉽게 입력값을 역추적할 수 있어야한다. 
                    </p>
                    <h5>벡터 공간의 선형 변환</h5>
                    <p>
                        · 2차원 벡터 공간에서 선형성(가법성, 1차 동차성을 만족)을 만족하려면 다음과 같아야할 것이다. <br>
                        · x, y 각각에 대해 선형성을 만족하려면 ax와 by같이 단순 비의 형태여야하고 <br>
                        · 이들을 섞은 결과는 ax + by와 같은 형태여야할 것이다. <br>
                        · 이 경우들을 적용한 것이 아래의 함수로 아래 함수는 벡터 공간에서 선형성을 만족하는 함수이다. <br>
                        · 이렇게 선형성을 유지시켜주는 함수를 선형 변환(linear transformation)이라고 한다. 
                    </p>
                    <div class = "equation-h5">
                        $f(\vec{v}) = f(x, y) = (ax+by, cx+dy)$
                    </div>
                    <h3>행렬</h3>
                    <p>
                        · 행렬은 수를 행과 열에 맞추어 사각형의 형태로 나열한 테이블이다. <br>
                        · 행렬은 선형 변환과 벡터를 나타낼 때 사용한다. 선형 변환에서는 열과 행의 크기가 같은 정방행렬(square matrix)를 사용한다. <br>
                        · 정방 행렬은 열과 행의 크기에 따라 '숫자 X 숫자 크기의 정방행렬' 이라고 한다. (예 2 X 2 크기의 정방행렬; 행과 열의 크기가 2인 정방 행렬)
                    </p>
                    <h5>행렬의 기본 연산</h5>
                    <div class = "content3">
                        · 행렬 + 행렬: 행과 열의 크기가 같은 경우만 가능 <br>
                        · 스칼라 * 행렬: 모든 행렬의 원소에 스칼라를 곱함 <br>
                        · 행렬의 전치: 모든 행과 열을 바꿈 (예: 2 X 3 → 3 X 2) <br>
                        · 행 * 행: 중요하므로 바로 밑의 '행렬의 곱셈'에서 다룸
                    </div>
                    <h5>행렬의 곱셈</h5>
                    <div class = "content3">
                        · 교환 법칙 X <br>
                        · 분배 법칙 O <br>
                        · 결합 법칙 O <br>
                        · 전치 연산의 특징: $(A·B)^{t} = B^{t}·A^{t}$
                    </div>
                    <h5></h5>
                    <p>
                        · 벡터 공간에서의 선형 변환 함수  $f(\vec{v}) = f(x, y) = (ax+by, cx+dy)$는 다음 행렬곱과 같다. 
                    </p>
                    <div class = "equation-h5" style = "text-align:left;">
                        $\begin{bmatrix}a&b\\c&d\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}=\begin{bmatrix}ax+by\\cx+dy\end{bmatrix}$<br>
                        <br>
                        즉, 어떤 정방 행렬 * 임의의 벡터 = 새로운 벡터
                    </div>
                    <h5></h5>
                    <p>
                        · 위 행렬 곱 수식 자체는 2차원 벡터에 선형 변환을 적용하여 새로운 벡터를 생성하는 작업에 대응된다. <br>
                        · 이 식에서 a, b, c, d가 있는 정방행렬이 선형 변환 함수와 대응되는 선형 변환 행렬이 된다. 
                    </p>
                    <h5>정방 행렬의 곱셈</h5>
                    <p>
                        · 앞서 설명한 행렬 곱의2X2정방행렬이 선형 변환 함수와 대응된다고 했다. <br>
                        · 이 정방 행렬의 곱은 합성함수와 대응된다. <br>
                        · 행렬의 곱셈은 결합 법칙을 만족한다. 
                    </p>
                    <h5><span class = "ref">참고</span> 열 기준 행렬과 행 기준 행렬</h5>
                    <p>
                        · 수학에서는 벡터를 열벡터로 나타내는 <span class = "keyword">열 기준 행렬</span>을 주로 사용<br>
                        · 열 기준 행렬은 연산 방향이 일반적인 연산 방향과 반대인 역방향으로 왼쪽에서 오른쪽이다. (열역)<br>
                        · 대표적인 사례로 게임 그래픽스 라이브러리인 OpenGL, 그리고 게임 엔진인 유니티가 있다. 
                    </p>
                    <div class = "equation-h5">
                        $\begin{bmatrix}a&b\\c&d\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}=\begin{bmatrix}ax+by\\cx+dy\end{bmatrix}$
                    </div>
                    <h5></h5>
                    <p>
                        · 하지만 컴퓨터에서 행렬을 응용할 때에는 <span class = "keyword">행 기준 행렬</span>을 쓰기도 한다. <br>
                        · 행 기준 행렬은 연산 방향이 일반적인 연산 방향과 같이 순방향으로 오른쪽에서 왼쪽이다. (행순)<br>
                        · 대표적인 사례로 게임 그래픽스 라이브러리인 다이렉트 X, 그리고 게임 엔진인 언리얼이 행 기준 행렬을 사용한다. 
                    </p>
                    <div class = "equation-h5">
                        $\begin{bmatrix}x&y\end{bmatrix}\begin{bmatrix}a&c\\b&d\end{bmatrix}=\begin{bmatrix}ax+by&cx+dy\end{bmatrix}$
                    </div>
                    <h5></h5>
                    <p>
                        · 열기준 행렬과 행기준 행렬의 연산은 전치를 통해 서로 변환할 수 있다. <br>
                        · <span class = "emphasis">이 책은 열 기준 행렬을 사용</span>하여 모든 행렬을 표현하였다. 
                    </p>
                    <div class = "equation-h5">
                        $(A·\vec{v})^T = \vec{v}^{T}·A^{T}$
                    </div>
                    <h3>행렬의 설계</h3>
                    <p>
                        · $R^{2}$상의 임의의 $\vec{v}$를 선형 변환한 $\vec{w}$를 구하는 행렬의 설계 방법은 아래와 같다. 
                    </p>
                    <div class = "equation-h3" style = "text-align:left;" id = "matrix-design">
                        우선 임의의 벡터를 선형 변환하기 위해 <br>
                        벡터 공간 V에 임의의 벡터인 $\vec{v}=(x,y)$를 생성해보자<br>
                        간편한 계산을 위해 선형 독립 관계인 표준 기저 벡터를 사용, 선형 결합식에 대입하면<br>
                        선형 결합식에 의해<br>
                        <br>
                        $\vec{v}=x(1,0)+y(0,1)=(x,y)$ <span class = "formula">식1</span><br>
                        <br>
                        이 성립한다. <br>
                        <br>
                        <br>
                        이제 $\vec{v}$를 선형 변환하기 위해 선형 결합식을 사용하여 $\vec{v}$를 선형 변환한 $\vec{w}$를 생성하면<br>
                        <br>
                        $\vec{w}=x(a,c)+y(b,d)=(ax+by, cx+dy)$ <span class = "formula">식2</span><br>
                        <br>
                        위 식을 행렬곱의 형태로 나타내면 <br>
                        즉, $R^{2}$ 상의 $\vec{v}$를 선형 변환한 결과 $\vec{w}$는 <br>
                        <br>
                        $\begin{bmatrix}a&b\\c&d\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}=\begin{bmatrix}ax+by\\cx+dy\end{bmatrix}$<br>
                        $\begin{bmatrix}a&b\\c&d\end{bmatrix}\vec{v}=\vec{w}$<br>
                        <br>
                        이다. <br>
                        <br>
                        여기서 $\vec{v}$를 생성하는 선형 결합식<span class = "formula">식1</span>과 $\vec{w}$를 생성하는 선형 결합식 <span class = "formula">식2</span>를 비교해보면<br>
                        행렬$\begin{bmatrix}a&b\\c&d\end{bmatrix}$의(a, c)와 (b, d)는 서로 선형 독립인 벡터임을 알 수 있다. <br>
                        <br>
                        즉, 2X2 크기의 정방행렬$\begin{bmatrix}a&b\\c&d\end{bmatrix}$를 설계하여 원하는 선형 변환 행렬을 만들 수 있다. 
                    </div>
                    <p>
                        · 위 행렬 설계에 대한 설명을 잘 이해하고 아래에서 부터 선형 변환 행렬을 만들고 이해해보자. 
                    </p>
                    <h5>크기 변환 행렬(scale transformation matrix)</h5>
                    <p>
                        · 어떤 벡터의 크기를 x는 a만큼 y는 b만큼 변환하는 행렬<br>
                    </p>
                    <div class = "equation-h5">
                        $S=\begin{bmatrix}a&0\\0&b\end{bmatrix}$
                    </div>
                    <h5>회전 변환 행렬(rotation transformation matrix)</h5>
                    <p>
                        · 어떤 벡터를 주어진 각θ로 회전하는 행렬
                    </p>
                    <div class = "equation-h5">
                        $R_{θ}=\begin{bmatrix}cosθ&-sinθ\\sinθ&cosθ\end{bmatrix}$
                    </div>
                    <h5>전단 변환 행렬(shear transformation matrix)</h5>
                    <p>
                        · 수평 전단과 수직 전단이 있다. <br>
                        · <span class = "keyword">수평 전단</span>은 수평으로 즉, x축 방향으로 y축에 대응하는 표준 기저 벡터를 미는 변환이다. <br>
                        · <span class = "keyword">수직 전단</span>은 수직으로 즉, y축 방향으로 x축에 대응하는 표준 기저 벡터를 미는 변환이다. <br>
                        · 수평 전단 행렬과, 수직 전단 행렬은 서로 전치 행렬이다. 
                    </p>
                    <div class = "equation-h5">
                        수평 전단 행렬<br>
                        <br>
                        $\begin{bmatrix}1&a\\0&1\end{bmatrix}$<br>
                        <br>
                    </div>
                    <span class = "emphasis">← 전치 →</span>
                    <div class = "equation-h5" style = "margin: 0;">
                        수직 전단 행렬<br>
                        <br>
                        $\begin{bmatrix}1&0\\a&1\end{bmatrix}$<br>
                        <br>
                    </div>
                    <h5>삼각함수의 덧셈 정리</h5>
                    <p>
                        · 의무 교육 과정에서 암기했던 이 공식을 회전행렬의 원리를 파악하면 행렬곱으로 덧셈 정리를 유도할 수 있다. 
                    </p>
                    <div class = "equation-h5">
                        회전에 두 각 $α$, $β$가 사용된다고 하자. 
                        회전 $R_{α}$와 $R_{β}$는 다음 공식이 성립한다. <br>
                        <br>
                            $R_{α}=\begin{bmatrix}cosα&-sinα\\sinα&cosα\end{bmatrix}$<br>
                            $R_{β}=\begin{bmatrix}cosβ&-sinβ\\sinβ&cosβ\end{bmatrix}$<br>
                        <br>
                        두 각을 더한 후 회전한 결과는 다음과 같다. <br>
                        <br>
                        $R_{(α+β)}=\begin{bmatrix}cos(α+β)&-sin(α+β)\\sin(α+β)&cos(α+β)\end{bmatrix}$<br>
                        <br>
                        두 각 $α$, $β$를 더한 후 회전한 결과는 결국 각$α$ 만큼 회전을 수행한 후, 각$β$ 만큼 회전을 수행한 결과와 동일하다. <br>
                        즉, 선형 변환 행렬을 사용한 벡터의 선형 변환을 활용하면 아래의 식이 성립한다. <br>
                        <br>
                        $R_{(α+β)}=R_{α}·R_{β}$ <br>
                        <br>
                        이다. <br>
                        <br>
                        $\begin{bmatrix}cos(α+β)&-sin(α+β)\\sin(α+β)&cos(α+β)\end{bmatrix}=\begin{bmatrix}cosαcosβ-sinαsinβ&-(cosαsinβ+sinαcosβ)\\cosαsinβ+sinαcosβ&cosαcosβ-sinαsinβ\end{bmatrix}$<br>
                        <br>
                        따라서 다음 식이 성립하며, 이를 <span class = "keyword">삼각함수의 덧셈 정리</span> 라고 한다. <br>
                        <br>
                        $cos(α+β) = cosαcosβ-sinαsinβ$<br>
                        $sin(α+β) = sinαcosβ+cosαsinβ$
                    </div>
                    <h3>역행렬</h3>
                    <p>
                        · 선형 변환에 사용되는 행렬은 본질적으로 함수의 성질을 지니므로, 항등 함수, 역함수에 대응하는 행렬이 존재한다. <br>
                        · 항등 함수에 대응하는 행렬을 <span class = "keyword">항등 행렬(identity matrix)</span>이라고 한다. <br>
                        · 항등 행렬은 원 공간의 변화 없이 동일한 공간으로 유지하는 변환을 의미한다. <br>
                        · 항등 행렬은 I로 나타내며 아래와 같다. 
                    </p>
                    <div class = "equation-h3">
                        앞서 학습한 <a href = "matrix-design">🔗행렬의 설계</a>부분의 식 유도 부분의 일부를 복습해보자. <br>
                        <br>
                        $\vec{v}=(x,y)$를 선형 변환하기 위해 선형 결합식을 사용하여 $\vec{v}$를 선형변환한 $\vec{w}$를 생성하면<br>
                        <br>
                        $\vec{w}=x(a,c)+y(b,d)=(ax+by, cx+dy)$<br>
                        <br>
                        위 식을 행렬곱의 형태로 나타내면 <br>
                        <br>
                        $\begin{bmatrix}a&b\\c&d\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}=\begin{bmatrix}ax+by\\cx+dy\end{bmatrix}$<br>
                        <br>
                        즉, $R^{2}$ 상의 $\vec{v}$를 선형 변환한 결과 $\vec{w}$는 <br>
                        <br>
                        $\begin{bmatrix}a&b\\c&d\end{bmatrix}\vec{v}=\vec{w}$<br>
                        <br>
                        이다. <br>
                        이 행렬곱이 <br>
                        <br>
                        $\begin{bmatrix}a&b\\c&d\end{bmatrix}\vec{v}=\vec{v}$<br>
                        <br>
                        이 되는 경우 앞의 2X2크기의 정방 행렬은 <br>
                        <br>
                        $I=\begin{bmatrix}1&0\\0&1\end{bmatrix}$<br>
                        <br>
                        이 되어야 하고 이를 <span class = "keyword">항등 행렬(identity matrix)</span>이라고 한다. 
                    </div>
                    <p>
                        · 역함수에 대응하는 행렬을 <span class = "keyword" id="inverse-matrix">역 행렬(inverse matrix)</span>이라고 한다. <br>
                    </p>
                    <div class = "equation-h3">
                        이제 항등 행렬을 유도 했으므로 유사한 방법으로 역행렬을 유도해보자. <br>
                        <br>
                        역 행렬은 아래의 조건을 만족해야한다. <br>
                        <br>
                        $\begin{bmatrix}a&b\\c&d\end{bmatrix}\vec{v}=I$<br>
                        <br>
                        여기서 항등 행렬$I$는 $\mathbb{R}^2$의 기저와 같기 때문에 <br>
                        결국, 역행렬의 곱은 선형 변환한 결과를 다시 원상태로 되돌리는 것이된다. <br>
                        <br>
                        역행렬은 위 첨자$^{-1}$을 사용하여 나타내고 임의의 행렬에 대해 다음과 같은 수식이 성립한다. <br>
                        <br>
                        $A·A^{-1}=A^{-1}·A=I$<br>
                        <br>
                    </div>
                    <p>
                        · 다음 목차에서 역행렬의 판별식과 크기, 전단, 회전, 행렬 곱에 대한 역행렬을 학습하자.
                    </p>
                    <h5>역행렬의 존재를 판별하는 행렬식</h5>
                    <p>
                        · 함수가 역함수를 가지려면 전단사함수여야하는 조건이 있듯, <br>
                        · 행렬도 함수이므로 두 공간 변환의 관계가 전단사 관계여야만 역행렬을 가진다. <br>
                        · 어떤 행렬이 역행렬이 존재하는지 파악할 수 있는 특별한 수식이 있는데 이를 <span class = "keyword">행렬식(determinant)</span>이라고 한다. <br>
                    </p>
                    <div class = "equation-h5">
                        행렬식은 $det()$기호로 표시하며 2X2 정방행렬 A의 행렬식은 다음과 같다. <br>
                        <br>
                        $A=\begin{bmatrix}a&b\\c&d\end{bmatrix}$<br>
                        $det(A)=ad-bc$<br>
                        <br>
                        행렬식 $det()=0$이면 역행렬이 존재하지 않는다. 왜 그런지 살펴보자. <br>
                        <br>
                        행렬 $A=\begin{bmatrix}a&b\\c&d\end{bmatrix}$의 열벡터 각각을 데카르트 좌표계 상에 배치해보자 <br>
                        배치 후 형성된 공간의 넓이는 좌표계를 그려 쉽게 파악할 수 있고, <br>
                        파악 한 결과는 행렬식과 같다. <br>
                        <br>
                        $ad-bc = det(A)$
                        <br>
                        <br>
                        앞서 학습했다시피, 역행렬은 임의의 행렬에 대해 다음과 같은 수식이 성립하여야만 한다. <br>
                        <br>
                        $A·A^{-1}=A^{-1}·A=I$ <span class = "formula">식 1</span><br>
                        <br>
                        수식은 행렬 곱의 형태이므로 결국 행렬 A에 역행렬A를 사용하여 I로 변환하는 것과 같다. <br>
                        <br>
                        하지만 행렬 A의 경우 데카르트 좌표계 상에서 열벡터로 생성한 공간의 넓이가 0이므로 <br>
                        두 벡터는 같은 선 상에 놓인 선형 종속 관계이다. <br>
                        선형 변환은 두 벡터가 선형 독립일 때만 가능하다. <br>
                        <br>
                        따라서, <span class = "formula">식 1</span>을 만족하는 역행렬A는 존재하지 못하므로 <br>
                        $det(A)=ad-bc=0$일 때, 역행렬은 존재하지 않는다. 
                    </div>
                    <h5><span class = "ref">참고</span> 행렬식 계산 결과가 음수가 나온다면? </h5>
                    <div class = "equation-h5">
                        단순하게 생각해보자 <br>
                        <br>
                        벡터 공간 $V$의 표준기저벡터 <br>
                        <br>
                        $e_{1}=(1, 0)$, $e_{2}=(0, 1)$<br>
                        <br>
                        이 변환되어 <br>
                        벡터 공간 $W$의 기저벡터<br>
                        <br>
                        $e'_{1}=(0, 1)$, $e'_{2}=(1, 0)$이 되었다고 하자. <br>
                        <br>
                        잘 보면 $e'_{1}=(0, 1)$, $e'_{2}=(1, 0)$는 <br>
                        결국 기저 벡터$e_{1}=(1, 0)$, $e_{2}=(0, 1)$가 서로 바뀐 것과 같다. <br>
                        <br>
                        이는 마치 손바닥면에서 손 등면으로 뒤집은 것과 똑 같은 의미라고 보면된다. <br>
                        (그림)<br>
                        이제 벡터 공간 V를 뒤집은 벡터 공간 W의 기저 벡터를 행렬로 나타낸 것을 A라하고 행렬식을 사용해보자. <br>
                        <br>
                        $A=\begin{bmatrix}a&b\\c&d\end{bmatrix}=\begin{bmatrix}0&1\\1&0\end{bmatrix}$<br>
                        $det(A)=ad-bc=0·0-1·1=-1$<br>
                        <br>
                        결과가 음수이다. 즉 행렬식의 결과가 음수라면 평면의 뒤를 의미한다고 할 수 있다. <br>
                        이처럼 행렬식의 부호를 사용하여 평면의 앞 뒤 판별, 설정을 할 수 있다. 
                    </div>
                    <h5>크기 변환 행렬의 역행렬</h5>
                    <div class = "equation-h5">
                        크기를 원래대로 돌리는 형태이므로 아래와 같다. <br>
                        <br>
                        $S^{-1}=\begin{bmatrix}\frac{1} {a}&0\\0&\frac{1} {b}\end{bmatrix}$
                        <br>
                    </div>
                    <h5>전단 변환 행렬의 역행렬</h5>
                    <div class = "equation-h5">
                        수평 전단 행렬의 역행렬<br>
                        <br>
                        $\begin{bmatrix}1&-a\\0&1\end{bmatrix}$<br>
                        <br>
                    </div>
                    <span class = "emphasis">← 전치 →</span>
                    <div class = "equation-h5" style = "margin: 0;">
                        수직 전단 행렬의 역행렬<br>
                        <br>
                        $\begin{bmatrix}1&0\\-a&1\end{bmatrix}$<br>
                        <br>
                    </div>
                    <h5 id = "rotate-inverse-matrix">회전 변환행렬의 역행렬</h5>
                    <div class = "equation-h5">
                        회전 변환행렬의 역행렬은 아래와 같다. <br>
                        <br>
                        $R_{θ}^{-1}=\begin{bmatrix}cosθ&sinθ\\-sinθ&cosθ\end{bmatrix}$<br>
                        <br>
                        회전 변환행렬을 유도해보자. <br>
                        <br>
                        회전 변환 결과를 회전하기 전으로 되돌리려면, 회전한 방향 만큼 반대방향으로 회전하면 된다. <br>
                        따라서 회전 변환 행렬의 역행렬은<br>
                        <br>
                        $R_{θ}^{-1} = R_{(-θ)}$<br><br>
                
                        $R_{θ}=\begin{bmatrix}cosθ&-sinθ\\sinθ&cosθ\end{bmatrix}$이므로, 
                        $R_{(-θ)}=\begin{bmatrix}cos(-θ)&-sin(-θ)\\sin(-θ)&cos(-θ)\end{bmatrix}$<br>
                        <br>
                        <a href = "#go-100">🔗삼각 함수의 성질</a>에 의해 아래가 성립한다. <br>
                        <br>
                        $R_{θ}^{-1}=\begin{bmatrix}cos(-θ)&-sin(-θ)\\sin(-θ)&cos(-θ)\end{bmatrix}=\begin{bmatrix}cosθ&sinθ\\-sinθ&cosθ\end{bmatrix}$<br>
                        <br>
                        이 식들을 잘 살펴보면 아래가 성립한다. <br>
                        <br>
                        $R_{θ}^{-1}=R_{(-θ)}=R_{θ}^{T}$<br>
                        <br>
                        즉, <span class = "emphasis">회전 변환 행렬의 역행렬는 회전 변환 행렬의 전치와 같다. </span><br>
                    </div>
                    <h5>행렬 곱의 역행렬</h5>
                    <div class = "equation-h5">
                        합성 함수의 역함수에 해당하는 두 행렬곱의 역행렬은 아래 수식이 성립한다. <br>
                        <br>
                        $(A·B)^{-1}=B^{-1}·A^{-1}$ <br>
                        <br>
                        이는 합성 함수의 역함수의 수식과 형태가 같다. <br>
                        이제 위 식을 증명해보자<br>
                        <br>
                        역행렬이 존재하는 A, B 행렬의 곱의 결과가 C라고 하자. <br>
                        <br>
                        $A·B=C$<br>
                        <br>
                        C도 역행렬이 존재한다면 아래 식이 성립한다. <br>
                        <br>
                        $C·C^{-1}=I$<br>
                        <br>
                        $A·B=C$이므로 이를 대입하면, <br>
                        <br>
                        $(A·B)·(A·B)^{-1}=I$<br>
                        <br>
                        위 식의 양변에 $A^{-1}$을 곱하면, <br>
                        <br>
                        $A^{-1}·(A·B)·(A·B)^{-1}=A^{-1}$<br>
                        <br>
                        행렬의 곱은 결합법칙이 성립하므로<br>
                        <br>
                        $(A^{-1}·A)·B·(A·B)^{-1}=A^{-1}$<br>
                        $B·(A·B)=A^{-1}$<br>
                        <br>
                        양변에 $B^{-1}$을 곱하면, <br>
                        <br>
                        $B^{-1}·B·(A·B)^{-1}=B^{-1}·A^{-1}$<br>
                        <br>
                        $(A·B)^{-1}=B^{-1}·A^{-1}$
                    </div>
                </div>
                <div class = "content2">
                    <h2>6장 아핀 공간: 움직이는 가상 세계의 구축</h2>
                    <h3>이동 변환을 위한 아핀 공간</h3>
                    <p>
                        · 앞서 학습했다시피, 2X2크기의 정방 행렬은 선형 변환 함수와 대응된다. <br>
                        · 선형 변환 함수는 선형성을 만족해야한다. <br>
                        · 선형성의 조건에 기저벡터는 반드시 원점을 지나야하는데 <br>
                        · 이동은 원점을 벗어날 수도 있으므로 선형성을 만족하지 못한다. <br>
                        · 그럼 이동 변환은 어떻게 해야할까? <br>
                        · 차원을 1차원 더 늘려 축을 하나 더 추가하면 해결할 수 있다. <br>
                    </p>
                    <div class = "equation-h3">
                        이동 변환 행렬은 아래와 같다. <br>
                        <br>
                        $T=\begin{bmatrix}1&0&a\\0&1&b\\0&0&1\end{bmatrix}$<br>
                        <br>
                        $T·\begin{bmatrix}x\\y\\1\end{bmatrix}=\begin{bmatrix}x+a\\y+b\\1\end{bmatrix}$<br>
                        <br>
                        (그림)
                        <br>
                        2차원의 이동은 3차원으로 확장하여 전단 변환을 수행하는 형태라고 보면된다. <br>
                        이는 결국 평면의 이동이 된다. <br>
                        <br>
                        마지막 차원값을 1로 한정한 부분 공간을 <span class = "keyword">아핀 공간</span>이라고 한다. 
                    </div><br>
                    <div class = "equation-h3">
                        이동 변환$T$가 3X3크기의 정방 행렬이므로, <br>
                        크기, 회전 변환을 이동 변환과 함께 쓰려면 <br>
                        그것들 또한 3X3크기의 정방 행렬로 만들면 된다. <br> 
                        즉 z축을 추가하면 된다. <br>
                        <br>
                        $S=\begin{bmatrix}a&0&0\\0&b&0\\0&0&1\end{bmatrix}$<br>
                        $R=\begin{bmatrix}cosθ&-sinθ&0\\sinθ&cosθ&0\\0&0&1\end{bmatrix}$<br>
                        <br>
                        이렇게 한 차원 높여 설계한 선형 변환을 <br>
                        <span class = "keyword">아핀 변환</span>이라고 한다. <br>
                        <br>
                        이동, 크기, 회전 변환 후에 생성되는 임의의 벡터들은 모두 마지막 차원 값이 1로, 아핀 공간에 닫힌 형태가된다. <br>
                        <br>
                        $\begin{bmatrix}a&0&0\\0&b&0\\0&0&1\end{bmatrix}\begin{bmatrix}x\\y\\1\end{bmatrix}=\begin{bmatrix}ax\\by\\1\end{bmatrix}$ (크기 변환 (S))<br>
                        $\begin{bmatrix}cosθ&-sinθ&0\\sinθ&cosθ&0\\0&0&1\end{bmatrix}\begin{bmatrix}x\\y\\1\end{bmatrix}=\begin{bmatrix}cosθx-sinθy\\sinθx+cosθy\\1\end{bmatrix}$ (회전 변환(R))<br>
                        $\begin{bmatrix}1&0&a\\0&1&b\\0&0&1\end{bmatrix}\begin{bmatrix}x\\y\\1\end{bmatrix}=\begin{bmatrix}x+a\\y+b\\1\end{bmatrix}$ (이동 변환(T))<br>
                    </div>
                    <h3>아핀 공간의 구성 요소</h3> 
                    <p>
                        · 아핀 공간의 정의에 따라 아핀 공간에 속한 물체의 마지막 차원 값은 항상 1이어야 한다. 
                    </p>
                    <h5>점</h5>
                    <div class = "equation-h5">
                        이동 가능한 2차원 아핀 공간의 점: $(x, y, 1)$<br>
                        이동 가능한 3차원 아핀 공간의 점: $(x, y, z, 1)$<br>
                        <br>
                        마지막 차원 값은 항상 1이어야만 한다. 1이외의 숫자가 오면 안된다. 
                    </div>
                    <h5>이동 벡터</h5>
                    <p>
                        · 이동 변환 행렬은 3X3크기의 정방 행렬이다. <br>
                        · 그렇기 때문에 변환을 위해 행렬 곱을 사용하려면 회전, 크기 변환도 3X3크기의 정방 행렬로 즉, 아핀 변환을 만들었다. <br>
                        · 아핀 변환을 사용하여 변환된 벡터들은 모두 아핀 공간에 닫혀있다고 앞서 학습하였다. <br>
                        · 그렇다면 벡터의 합 연산을 사용하여 아핀 공간의 원소인 점을 이동시켜보자. <br>
                        · 이 경우도 이동된 점은 아핀공간에 닫혀있어야한다. <br>
                        · 아핀 공간에 닫히도록 이동시키기 위해 벡터 라는 것을 사용한다. <br>
                        · 여기서 벡터는 3장의 벡터와는 같은 단어지만 다른 용도로 쓰인다. 이와 구분하기 위해 아핀 공간의 벡터를 <span class = "keyword">이동벡터</span>혹은 <span class = "keyword">변위벡터</span>라고 부른다. 
                    </p>
                    <div class = "equation-h5">
                        아핀 공간의 점 $P_{1}=(x_{1}, y_{1}, 1)$에 이동 벡터 $\vec{v}$를 더한 결과를 $P_{2}=(x_{2}, y_{2}, 1)$라고 하면 아래와 같다. <br>
                        <br>
                        $P_{1}+\vec{v}=P_{2}$<br>
                        <br>
                        위 식을 살펴보면, $P_{1}$에서 $\vec{v}$만큼 이동하여 $P_{2}$로 향함을 알 수 있다. <br>
                        위 식에서 $P_{1}$을 우변 이항하여, 이동 벡터를 구하면 아래와 같다. <br>
                        <br>
                        $\vec{v}=P_{2}-P_{1}$<br>
                        $(x_{1}-x_{2}, y_{1}-y_{2}, 0)=(x_{1}, y_{1}, 1)-(x_{2}, y_{2}, 1)$<br>
                        <br>
                        즉, <span class = "emphasis">이동 벡터($\vec{v}$) = 목표 점($P_{2}$) - 시작 점($P_{1}$)</span>이다. <br>
                        그리고 이동 벡터는 마지막 차원값이 0이므로 점이 있는 아핀 공간과 다른 공간에 위치한다. <br>
                        (그림 208)<br>
                        벡터의 뺄셈은 교환 법칙이 성립하지 않으므로 위 식을 반대로 빼면 다른 결과가 나오므로 주의한다. <br>
                        <br>
                        $-\vec{v}=-P_{2}+P_{1}$<br>
                        $\therefore-\vec{v}=P_{1}-P_{2}$<br>
                        <br>
                        반대로 빼면 반대 방향의 이동 벡터이다. 
                    </div>
                    <h5>아핀 공간의 성질</h5>
                    <p>
                        · 물리적 관점에서 현실의 3차원 공간을 <span class = "keyword">유클리드 공간(Euclidean space)</span>(아핀 공간과 대응)<br>
                        · 유클리드 공간에서 작용하는 힘을 <span class = "keyword">유클리드 벡터(Euclidean vector)</span>(이동 벡터와 대응)<br>
                        · 이렇듯 콘텐츠를 다룰 때에는 점과 이동벡터를 구분하여 설계하는 것이 효과적이다. <br>
                        · <span class = "emphasis">앞으로 이 책에서 '이동 벡터'를 '벡터'라고 지칭할 것이다. </span><br>
                    </p>
                    <div class = "content3">
                        · 점과 벡터의 <span class = "emphasis">마지막 차원 값을 토대</span>로 두 요소사이에는 다음과 같은 연산 규칙이 성립한다. <br>
                        · 앞서 계속 학습했듯, 아핀공간은 점의 영역, 이동 벡터의 영역은 이동 벡터의 영역이다. <br>
                        <br>
                        · 점-점 = 벡터 (1 - 1 = 0)<br>
                        · 점+벡터 = 점(1 + 0 = 1)<br>
                        · 벡터+벡터 = 벡터(0 + 0 = 0)<br>
                        · 점 + 점 != 점 (1 + 1 = 2)
                    </div>
                    <h3>아핀 결합</h3>
                    <p>
                        · 바로 위에서 학습했듯, 점 + 점으로 점을 생성할 수는 없다. 왜냐하면, 마지막 차원이 2이기때문이다. <br>
                        · 하지만, 선형 결합의 형태로 '스칼라·점1 + 스칼라2·점2'의 결과는 특정 조건을 만족하면 새로운 점을 생성가능하다. <br>
                    </p>
                    <div class = "equation-h3">
                        임의의 두 점 $P_{1}=(x_{1}, y_{1}, 1)$, $P_{2}=(x_{2}, y_{2}, 1)$를 선형 결합 형태로 나타내면 아래와 같다. <br>
                        <br>
                        $a·P_{1}+b·P_{2}=(ax_{1}+bx_{2},\space ay_{1}+b_y{2},\space a+b)\space\space\space\space\space(s.t.\space\space\space a+b=1)$<br>
                        <br>
                        즉, 마지막 차원값을 1로 한정하여 선형 결합의 형태를 사용하면 점을 생성할 수 있게 된다. <br>
                        <br>
                        점을 계속 추가하면 다음과 같은 수식이 성립하게 된다. <br>
                        <br>
                        $\sum_{n}^{i=1}c_{i}·P_{i} \space\space\space\space\space (s.t.\space\space\space \sum_{n}^{i=1}c_{i}=1)$<br>
                        <br>
                        이렇게 여러 개의 점을 결합하여 새로운 점을 생성하는 수식을 <span class = "keyword">아핀 결합</span>이라고 한다. 
                    </div>
                    <h5 id = "two-verticies">두 점의 결합</h5>
                    <div class = "equation-h5">
                        바로 위 아핀 결합 목차에서 학습한 임의의 두 점$P_{1}=(x_{1}, y_{1}, 1)$, $P_{2}=(x_{2}, y_{2}, 1)$의 선형 결합의 형태로 나타낸 결과$P^{'}$의 식을 보자. <br>
                        <br>
                        $a·P_{1}+b·P_{2}=(ax_{1}+bx_{2},\space ay_{1}+b_y{2},\space a+b)=P^{'}\space\space\space\space\space(s.t.\space\space\space a+b=1)$<br>
                        <br>
                        두 스칼라의 합이 1인 $a+b=1$식을 b에 관하여 푼 후 위 식에 대입하면 아래와 같다. <br>
                        <br>
                        $a+b=1$<br>
                        $b=1-a$<br>
                        $\therefore a·P_{1}+(1-a)·P_{2}=P^{'}$<span class = "formula">식 1</span><br>
                        <br>
                        <span class = "formula">식 1</span> 을 정리해보자. <br>
                        <br>
                        $a(P_{1}-P_{2}) = P^{'}-P_{2}$<br>
                        <br>
                        $P_{1}-P_{2}$를 $\vec{v}$, $P^{'}-P_{2}$를 $\vec{u}$라고하면 아래와 같다. <br>
                        <br>
                        $a·\vec{v}=\vec{u}$<br>
                        <br>
                        즉, $\vec{v}$의 스칼라 배가 $\vec{u}$이므로 두 백터는 서로 평행한 벡터로 <br>
                        두 점의 아핀 결합으로 생성되는 점은 $P_{2}$에서$P_{1}$을 지나는 직선 상에 모두 위치한다. <br>
                        결국 <span class = "formula">식 1</span>에 모든 실수 a를 대입하면 양 끝으로 무한이 뻗은 선 직선이 형성된다. <br>
                        a의 범위에 따라 형성되는 선의 형태는 다음과 같다. <br>
                        <br>
                        $-∞&lt;a&lt;∞$ (직선(line))<br>
                        $0&lt;a&lt;∞$ (반직선(ray))<br>
                        $0&lt;a&lt;1$ (선분(line segment))<br>
                        <br>
                        즉, <span class = "formula">식 1</span>을 정리하면 $L(a)$라 표현하고, <span class = "keyword">직선의 방정식</span>이라고 한다. <br>
                        <br>
                        $L(a)=a·P_{1}+(1-a)·P_{2}$
                    </div>
                    <h3>선 그리기 알고리즘</h3>
                    <h5>벡터를 모니터의 점으로 표현</h5>
                    <table>
                        <tr>
                            <th></th>
                            <th>데카르트 좌표계</th>
                            <th>스크린 좌표계</th>
                        </tr>
                        <tr>
                            <td>수 집합</td>
                            <td>실수</td>
                            <td>정수</td>
                        </tr>
                        <tr>
                            <td>수의 성질</td>
                            <td>연속성</td>
                            <td>이산성</td>
                        </tr>
                        <tr>
                            <td>단위 원소</td>
                            <td>벡터</td>
                            <td>픽셀</td>
                        </tr>
                        <tr>
                            <td>수의 범위</td>
                            <td>실수 범위</td>
                            <td>0부터 해상도 크기까지</td>
                        </tr>
                    </table>
                    <h5></h5>
                    <p>
                        · 지금까지 학습한 내용으로 컴퓨터 모니터 화면에 선을 그어보자. <br>
                        · 수학에서는 데카르트 좌표계를 쓰지만, 모니터에서는 <span class = "keyword">스크린 좌표계</span>를 쓴다. <br>
                        (그림 215-1)<br>
                        · 데카르트 좌표계는 실수를 사용하여 연속된 실수로 평면을 채울 수 있다. <br>
                        · 스크린 좌표계는 모니터의 픽셀이라는 하드웨어 때문에 특정 칸을 나타내기 위해 정수를 사용 이산적인 실수로 독립된 공간을 가진다. <br>
                        · <span class = "keyword">필셀(pixel)</span>이란 모니터에 빛으로 RGB를 표현하게 해주는 작은 장치이다. 매우 작기 때문에 수많은 픽셀이 모여서 하나의 모니터 화면을 이룬다. <br> 
                        · 즉, 픽셀은 색상 정보를 가지고 있다. <br>
                        · 데카르트 좌표계상의 벡터 좌표를 스크린 좌표계로 변환하여 모니터 화면에 표현하려면 <br>
                        · 벡터 좌표를 정수로 변환한 후 색상 정보를 부여해야한다. 이 과정을 <span class = "keyword">픽셀화(rasterization)</span>라고 한다. <br>
                        (그림 215-2)<br>
                        · 픽셀화 시 한가지 고려해야할 주요 사항이 있다. <br>
                        · <span class = "emphasis">데카르트 좌표계 → 스크린 좌표계 변환 시</span><br>
                        · 모니터 해상도가 짝수이면 데카르트 좌표계의 원점$(0, 0)$을 표현할 때 스크린 좌표계의 4점 중 하나를 사용해야 하는데<br>
                        · 이는 그 4점중 하나를 픽셀을 선택하여 표현한다. 이는 사용하는 그래픽 엔진에 따라 다른 규칙이 적용될 것이다. <br>
                        (그림 215-3)<br>
                        · <span class = "emphasis">스크린 좌표계 → 데카르트 좌표계 변환 시</span><br>
                        · 스크린 좌표계는 픽셀이 원소이고 픽셀은 크기가 가로 세로[0, 1]범위이므로, 데카르트 좌표계의 벡터 원소로 변환 시 그 사이의 어떤 값으로 변환해야 할 것이다. <br>
                        · 이 책에서 사용하는 CK소프트랜더러는 픽셀의 중심영역을 사용한다. <br>
                        (그림 215-4)<br>
                    </p>
                    <h5>선 그리기 알고리즘</h5>
                    <p>
                        · 데카르트 좌표계를 스크린 좌표계로 옮겨 정수만을 사용하여 효율적으로 선분을 그리는 알고리즘이 있다. <br>
                        · 1962년에 발표된 대표적인 방법으로 <span class = "keyword">브레젠험 알고리즘(bresengam's algorithm)</span>이라고 한다. <br>
                        · 1962년에 발표된 만큼 초창기 컴퓨터에서도 사용가능하도록 고안되었기 때문에, 구현이 단순하고 속도도 빠르다. <br>
                    </p>
                    <div class = "equation-h5">
                        브레젠험 알고리즘은 스크린 좌표계를 8등분 하여 나타낸다. <br>
                        8등분 한 분면을 순서대로 각각 <span class = "keyword">n팔 분면</span>이라고 한다. (데카르트 좌표계는 4등분 이므로 n사분면)<br>
                        <br>
                        (그림 219-1)<br>
                        <br>
                        우선 첫 분면인 1팔 분면을 보자. <br>
                        1팔 분면은 [0˚, 45˚]의 범위를 가진다. <br>
                        즉, 해당 팔분면은 선의 기울기가 1을 넘을 수 없다. <br>
                        <br>
                        이제, 스크린 좌표에 선분을 그리기 위해 스크린 좌표에서 선분의 시작 픽셀과 임의의 끝 픽셀을 지정하자. <br>
                        시작 픽셀을 $(x_{0}, y_{0})$이라고 하고, <br>
                        시작 픽셀에서 임의의 끝 픽셀 까지의 길이 즉, 선분의 길이에서 너비를 $w$, 높이를 $h$라고 하자. <br>
                        <br>
                        (그림 *)<br>
                        <br>
                        이제 시작 픽셀에서 이어지는 오른쪽에 위치한 픽셀 중 어느 픽셀을 찍을지 알아보자. <br>
                        우선 2가지가 있다. <br>
                        <br>
                        $(x_{0}+1, y_{0})$<br>
                        $(x_{0}+1, y_{0}+1)$<br>
                        <br>
                        브레젠험 알고리즘은 위 두 가지 픽셀이 접하는 중점 위치를 선택한다. <br>
                        따라서, 브레젠험 알고리즘을 <span class = "keyword">중점 알고리즘</span>이라고도 한다. <br>
                        그 중점의 위치는 아래와 같다. <br>
                        <br>
                        $(x_{0}+1, y_{0}+0.5)$<span class = "formula">1</span><br>
                        <br>
                        (그림 220-3)<br>
                        <br>
                        직선의 방정식 $y=ax+b$를 사용해보자. <br>
                        직선의 방정식에서 $a$는 기울기이므로 임의의 기울기로 치환하면 되고<br>
                        $b$는 시작 픽셀의 좌표$(x_{0}, y_{0})$를 대입한 후, $b$에 관하여 풀면 된다. 그렇게 하면 아래와 같다. <br>
                        <br>
                        $y_{0}=\frac{h} {w}x_{0}+b$<br>
                        <br>
                        $b=y_{0}-\frac{h} {w}x_{0}$<br>
                        <br>
                        이제 $b$에 관하여 푼 식으로 직선의 방정식의 b를 치환하면 아래과 같다. <br>
                        <br>
                        $y=\frac{h} {w}x+y_{0}-\frac{h} {w}x_{0}$<br>
                        <br>
                        이렇게 하면 y 값을 구할 수 있다. 이제 이 y값을 <span class = "formula">1</span>과 비교해보자. <br>
                        <br>
                        $\frac{h} {w}x+y_{0}-\frac{h} {w}x_{0}&lt;y_{0}+0.5$<br>
                        <br>
                        위 식을 통해 알 수 있는 것은 <br>
                        좌항&lt;우항 이면 $y_{0}+0.5$ 바로 윗 픽셀 즉, 오른쪽 수평 방향의 픽셀을 찍는다. <br>
                        좌항&gt;우항 이면 $y_{0}+0.5$ 바로 아래 픽셀 즉, 오른쪽 아래의 픽셀을 찍는다. <br>
                        x좌표 값은 비교하지 않는데, 이는 선분이기 때문에 x값의 좌표는 굳이 몰라도 된다. <br>
                        왜냐하면, 선분이기 떄문에 픽셀 연속적으로 찍히기 때문이다. <br>
                        <br>
                        이제 위 식을 간단히 해보자. <br>
                        <br>
                        <div style = "text-align: left;">
                            $\frac{h} {w}x_{0}+y_{0}-\frac{h} {w}x_{0}&lt;y_{0}+0.5$<br>
                            $hx+wy_{0}-hx_{0}&lt;wy_{0}+0.5w$ (양 변에 $w$ 곱함)<br>
                            $h(x-x_{0})-0.5w&lt;0$(우변을 좌변으로 이항 후, $h$로 묶음)<br>
                            $2h(x-x_{0})-w&lt;0$(모든 항을 정수로 만들기 위해 양변에 2를 곱함)<br>
                            $2h(x_{0}+1-x_{0})-w&lt;0$($x$에 $x_{0}$대입)<br>
                            $2h-w&lt;0$<br> 
                        </div>
                        이로써 1팔 분면에서 높이와 너비만으로 두 번째 픽셀의 위치를 계산 할 수 있게 되었다. <br>
                        세 번째 필셀은 좀 더 까다롭다. 즉, 선분을 그리기 위한 픽셀을 찍을 수록 점점 경우의 수가 많아진다. <br>
                        <br>
                        (그림220-3)(그림222-1)(그림223-1)<br>
                        <br>
                        픽셀을 찍기 위한$x$값이 증가 할수록 판별식은 $2h$만큼 증가한다. <br>
                        그리고 한칸 내려갈 수록 판별식은 $2w$만큼 줄어든다. 이를 판별하는 각 중점의 판별식은 아래와 같다. <br>
                        (그림223-2)<br>
                        각 팔분면마다 판별식에 일정한 규칙이 존재하므로, 아래 방법 그림에 적힌 방법으로 어떤 식으로 구해지는지 생각해보자. <br>
                        (아래 그림의 팔분면에 표현된 스크린 좌표계는 스크린 좌표계 중점이 아님 그냥 x, y축의 증가량을 보기 편하게 표시한 것 뿐임! )
                        <br>
                        <figure><img src = "../img/math-01.jpg" width="80%"></figure><br>
                        이런 식으로 모든 팔분면을 계산해보면 다음과 같은 규칙이 생성된다. <br>
                        <br>
                        1팔분면: $2h-w$로, 각각$+2h ,-2w$씩 변화<br>
                        2팔분면: $-h+2w$로, 각각$-2h, +2w$씩 변화<br>
                        3팔분면: $h+2w$로, 각각$-2h, +2w$씩 변화<br>
                        4팔분면: $2h+w$로, 각각 $+2h, +2w$씩 변화<br>
                        5팔분면: $2h-2w$로, 각각 $+2h-2w$씩 변화 ?<br>
                        6팔분면: <br>
                        7팔분면:<br>
                        8팔분면:<br>
                    </div>
                    <h5>라인 클리핑 알고리즘</h5>
                    <p>
                        · 우리가 보이는 화면에만 선을 그리도록 제한해주는 알고리즘이다. <br>
                         
                    </p>
                </div>
                <div class = "content2">
                    <h2>7장 내적: 벡터 공간의 분석과 응용</h2>
                    <h3>벡터의 내적</h3>
                    <p>
                        · 같은 차원의 두 벡터의 성분을 곱한 후 더해 스칼라를 만드는 연산이다. <br>
                        · 가운뎃점(·)연산자를 사용하는데 곱셈과 동일한 연산자이다. <br>
                        · 내적은 벡터 응용에서 자주 쓰이는 중요한 공식이다. <br>
                        · 컴퓨터 그래픽에서 실시간으로 변화하는 효과를 구현하는데 유용하다. 
                    </p>
                    <div class = "equation-h3">
                        2차원 벡터의 내적 공식은 아래와 같다. <br>
                        <br>
                        $\vec{u}=(a, b), \vec{v}=(c, d)$<br>
                        <br>
                        $\vec{u}·\vec{v}=a·c+b·d$
                    </div>
                    <h5>내적의 성질</h5>
                    <div class = "content3">
                        $\vec{u}·\vec{v}=\vec{v}·\vec{u}$: 교환 법칙 > <span class = "emphasis">O</span><br>
                        $\vec{u}·(\vec{v}·\vec{w})\neq(\vec{u}·\vec{v})·\vec{w}$: 결합 법칙 > <span class = "emphasis">X</span><br>
                        $\vec{w}·(\vec{u}+\vec{v})=\vec{u}·\vec{w}+\vec{v}·\vec{w}$: 덧셈에 대한 분배법칙 > <span class = "emphasis">O</span><br>
                    </div>
                    <div class = "equation-h5">
                        <span class = "emphasis">이는 모든 차원의 벡터에서 동일하게 적용된다. </span><br>
                        <span class = "emphasis">같은 벡터의 내적은 그 벡터 크기의 제곱이다. </span><br>
                        <br>
                        $\vec{v}=(x, y)$자체를 내적해보자. <br>
                        <br>
                        $\vec{v}·\vec{v}=x·x+y·y=x^{2}+y^{2}$<br>
                        <br>
                        $\therefore\vec{v}·\vec{v}=||\vec{v}||^{2}$
                    </div>
                    <br>
                    <div class = "equation-h5">
                        내적은 교환법칙, 분배법칙을 만족한다. 따라서, <br>
                        <br>
                        $(\vec{u}+\vec{v})·(\vec{u}+\vec{v})=\vec{u}·\vec{u}+\vec{v}·\vec{v}+2(\vec{u}·\vec{v})$<br>
                        <br>
                        $=||\vec{u}||^{2}+||\vec{v}||^{2}+2(\vec{u}·\vec{v})$
                    </div>
                    <h5><span class = "ref">참고</span> 벡터 크기의 정의</h5>
                    <p>
                        · 앞서 벡터의 크기를 정의할 때 피타고라스 정의를 활용하여 최단 거리 개념으로 설명했다. <br>
                        · 그런 기하학적 요소를 완전 배제한다면, 벡터의 크기는 자신을 내적한 결과의 제곱근으로 정의할 수 있다. 
                    </p>
                    <h5>내적과 삼각함수와의 관계</h5>
                    <div class = "equation-h5">
                        두 벡터 $\vec{u}$, $\vec{v}$의 사잇각을 $θ$라 할때 내적과 $cos$함수의 관계는 아래와 같다. <br>
                        <figure><img src = "../img/math-02.jpg" width = 80%></figure>
                        <br>
                        $\vec{u}·\vec{v}=|\vec{u}||\vec{v}|cosθ$<br>
                        <br>
                        따라서, 두 벡터$\vec{u}$, $\vec{v}$의 크기가 1이면 아래의 식이 성립한다. <br>
                        <br>
                        $\vec{u}·\vec{v}=cosθ$<br>
                        <br>
                        즉, <span class = "emphasis">두 벡터를 정규화한 후 내적의 결과는 두 벡터$\vec{u}$, $\vec{v}$가 이루는 '사잇각'을 cos함수에 전달한 후 도출된 결과값이다. </span><br>
                        위 식은 자주 사용하므로 꼭 이해하고 넘어가자. <br>
                        즉, 두 벡터 $\vec{u}$, $\vec{v}$의 내적 값이 0이면<br>
                        <br>
                        $cosθ = 0$<br>
                        <br>
                        $\therefore cos90˚$, $cos270˚$ 이다. <br>
                        <br>즉, 두 벡터의 직교성을 판별할 때 유용하다. <br>
                        <br>
                        <figure><img src = "../img/math-05.jpg" width = 80%></figure>
                    </div>
                    <h5>행렬의 곱셈을 내적으로 표현하기</h5>
                    <div class = "equation-h5">
                        행렬 X 벡터 혹은 행렬 X 행렬 = <span class = "emphasis">행렬의 모든 행벡터 와 벡터의 모든 열 벡터끼리의 내적</span>으로 나타낼 수 있다. <br>
                        행렬 X 벡터의 경우는 아래와 같다. <br>
                        <br>
                        $\begin{bmatrix}a&b\\c&d\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}=\begin{bmatrix}ax+by\\cx+dy\end{bmatrix}=\begin{bmatrix}(a, b)·(x, y)\\(c, d)·(x, y)\end{bmatrix}$<br>
                        <br>
                        행렬 X 행렬의 경우도 마찬가지이므로 생략한다. <br>
                    </div>
                    <h5></h5>
                    <p>
                        · <span class = "keyword">직교 행렬(orthogonal matrix)</span>은 정방 행렬의 모든, 행, 열벡터의 크기가 1이고 벡터가 서로 직교하는 행렬이다. <br>
                        · $Q$로 표현한다. 
                    </p>
                    <div class = "equation-h5">
                        $Q=\begin{bmatrix}a&c\\b&d\end{bmatrix}$<br>
                        <br>
                        여기서 $(a, b)$, $(c, d)$, $(a, c)$, $(b, d)$의 크기는 1, $(a, b)$, $(c, d)$는 서로 직교(따라서 직교 행렬)한다. <br>
                        직교 행렬의 전치는 직교행렬의 역행렬이다. 따라서, 아래 식이 성립한다. <br>
                        <br>
                        $Q·Q^{T}=I$ <span class = "formula">식 1</span><br>
                        <br>
                        회전 변환 행렬은 각 행, 열벡터의 크기가 1, 열벡터가 서로 직교하므로 직교 행렬이다. <br>
                        <br>
                        $R_{θ}=\begin{bmatrix}cosθ&-sinθ\\sinθ&cosθ\end{bmatrix}$<br>
                        <br>
                        회전 행렬이 직교 행렬인 이유를 다른 방식으로 알아보자. <br>
                        앞서 학습한 <a href = "#inverse-matrix">🔗역행렬의 조건</a>과 <a href = "#rotate-inverse-matrix">🔗회전 행렬의 역행렬</a>에 의해 아래 식이 성립한다. <br>
                        <br>
                        $R_{θ}·R_{θ}^{T}=I$<br>
                        <br>
                        위 식은 <span class ="formula">식 1</span>의 형태이므로 <br>
                        <span class = "emphasis">회전 행렬은 직교 행렬이다. </span>
                    </div>
                    <h5></h5>
                    <p>
                        · 선형 변환 중 변환 후에도 물체의 형태가 그대로 유지되는 변환을 <span class = "keyword">강체 변환(rigid transformation)</span>이라고 한다. <br>
                        · 선형 변환이 강체 변환이 되기위한 조건은 다음과 같다. <br>
                    </p>
                    <div class = "content3">
                        1. 변화된 기저벡터의 크기는 모두 1이어야한다. <br>
                        2. 모든 기저벡터는 서로 직교해야 한다. <br>
                        3. 행렬식의 값이 1이어야 한다. <br>
                    </div>
                    <div class = "equation-h5">
                        회전 변환이 강체 변환의 성질인지 확인해보자. <br>
                        앞서 학습했듯, 직교 행렬의 성질에 의해 1., 2. 는 만족한다. <br>
                        3. 행렬식의 값이 1이어야한다. 또한 성립한다. 아래를 보자. <br>
                        <br>
                        $R_{θ}=\begin{bmatrix}cosθ&-sinθ\\sinθ&cosθ\end{bmatrix}$<br>
                        <br>
                        $cosθ^{2}+sinθ^{2}=1$<br>
                        <br>
                        <span class = "emphasis">따라서 회전 변환은 강체 변환의 성질</span>을 가진다. 
                    </div>
                    <h3>시야 판별</h3>
                    <p>
                        · 벡터의 내적은 공간의 분석에 유용하게 사용된다. 
                    </p>
                    <h5>앞뒤 판별</h5>
                    <p>
                        · 내적의 부호로 캐릭터를 기준으로 목표물이 앞에 있는지 뒤에 있는지 판별 가능하다. <br>
                    </p>
                    <div class = "equation-h5">
                        <figure><img src = "../img/math-02.jpg" width = 70%></figure><br>
                        앞서 조금 전에 학습한 내적과 $cos$함수의 관계로 이해해보자. <br>
                        <br>
                        캐릭터의 전방 벡터를 $\vec{u}$<br>
                        캐릭터에서 목표물 까지의 벡터를 $\vec{v}$라 하면, <br>
                        사잇각 $θ$에 따른 $cos$함수의 부호로 캐릭터 기준 목표물의 앞에 있는지 뒤에 있는지 내적 결과의 부호로 판별할 수 있다. <br>
                        (그림 *)
                        <div class = "content3">
                            내적 결과 + : 캐릭터의 앞<br>
                            내적 결과 0 : 캐릭터와 직교 (나란히 옆)<br>
                            내적 결과 - : 캐릭터의 뒤 <br>
                        </div>
                    </div>
                    <h5>시야 판별</h5>
                    <p>
                        · 내적을 이용하여, 캐릭터에 시야각을 부여하고, 그 시야각 안에 목표물이 들어왔는지 확인할 수 있다. <br>
                    </p>
                    <div class = "equation-h5">
                        (그림 *)
                        캐릭터의 보편적인 전방시야각의 범위는 [0˚, 180˚]이다. <br>
                        캐릭터의 전방 벡터를 $\vec{u}$, 캐릭터에서 목표물 까지의 벡터를 $\vec{v}$, 두 벡터의 사잇각을 $α$라고 하자<br>
                        앞서 학습했듯, 내적과 $cos$함수의 관계에 의해 아래 식이 성립한다. <br>
                        <br>
                        $\vec{u}·\vec{v}=|\vec{u}||\vec{v}|cosα$<br>
                        <br>
                        계산의 편의를 위해 각각의 벡터를 크기를 1로 만들어 정규화 하자. 그러면 아래 식이 성립한다. <br>
                        <br>
                        $\hat{u}·\hat{v}=cosα$<br>
                        <br>
                        캐릭터에 부여된 시야각의 특성을 파악해보자. <br>
                        캐릭터의 시야각 크기를 $β$라고 하면<br>
                        보편적으로 시야각은 캐릭터의 전방 백터를 기준으로 양쪽으로 반씩 나뉘어지는 형태이다. <br>
                        따라서, $\vec{u}$, $\vec{v}$의 내적 값인 $cosα$와 <br>
                        판별을 위해 시야각의 절반을 $cos$함수에 전달한 결과값 $cosβ/2$를 비교하면 <br>
                        cos함수에 의해 아래가 성립한다. <br>
                        <div class = "content3">
                            $cosα \geq cosβ/2$: 목표물이 시야 범위 <span class = "emphasis">안</span>에 있음<br>
                            $cosα < cosβ/2$: 목표물이 시야 범위 <span class = "emphasis">밖</span>에 있음<br>
                        </div>
                    </div>
                    <h3>조명 효과의 구현</h3>
                        <div class = "equation-h3">
                            <span class = "keyword">렘버트 반사(Lambertian reflection) 모델</span>은 빛을 받아 표면에서 반사되는 빛의 세기는 두 벡터의 사잇각의 코사인 함수에 비례한다는 모델이다.  <br>
                            (그림 *)<br>
                            즉, 표면이 향하는 단위 벡터를 $\hat{u}$, <br>
                            표면에서 광원으로 향하는 단위 벡터를 $\hat{v}$라고 하면, 아래 식이 성립한다. <br>
                            <br>
                            $\hat{u}·\hat{v}=cosθ$<br>
                            <br>
                            $cos90˚ = 0$(빛이 X), $cos0˚ = 1$(빛이 1)이다. 
                        </div>
                    <h3>투영 벡터</h3>
                    <p>
                        · 벡터 내적은 어떤 벡터를 다른 벡터에 직교 투영하는 용도로 사용된다. <br>
                        · 카메라와 물체 사이의 거리 이외에도 카메라에서 물체까지의 깊이 갚도 필요할 경우도 있다. <br>
                        · 이 경우 내적을 활용한 투영 벡터를 구하는 공식이 사용된다. <br>
                    </p>
                    <div class = "equation-h3">
                        벡터 $\vec{u}$, $\vec{v}$가 있고 $\vec{u}$를 $\vec{v}$에 투영한 벡터 $\vec{v}^{'}$가 있다고 하자. <br>
                        벡터 $\vec{v}$에 투영하였으므로 투영된 벡터는 $\vec{v}^{'}$이다. <br>
                        따라서 $\vec{v}$와 $\vec{v}^{'}$는 서로 같은 선 상에 놓인다. <br>
                        <br>
                        같은 선 상에 놓였으므로 투영 벡터 $\vec{v}^{'}$는 아래와 같은 식으로 구할 수 있다. <br>
                        <br>
                        $\vec{v^{'}}=|\vec{v^{'}}|·\hat{v}$<br>
                        <br>
                        위 식을 정리해보자. <br>
                        <br>
                        <div style = "text-align: left;">
                            $\vec{v^{'}}=|\vec{v^{'}}|·\frac{\vec{v}} {|\vec{v}|}$&emsp;&emsp;(벡터 $\vec{v}$의 단위 벡터를 구하는 방법을 대입)<br>
                            $=|\vec{u}|·cosθ·\frac{\vec{v}} {|\vec{v}|}$&emsp;&emsp;($cosθ=\frac{|\vec{v^{'}}} {\vec{u}}, cosθ|\vec{u}|=|\vec{v^{'}|}$ 대입)<br>
                            $=|\vec{u}|·\frac{\vec{u}·\vec{v}} {|\vec{u}||\vec{v}|}·\frac{\vec{v}} {|\vec{v}|}$<br>
                            $=\frac{(\vec{u}·\vec{v})} {|\vec{v}|^{2}}·\vec{v}$<br>
                            $=\frac{(\vec{u}·\vec{v})} {\vec{v}·\vec{v}}·\vec{v}$&emsp;&emsp;($|\vec{v}|^{2}=\vec{v}·\vec{v}$ 대입)<br>
                        </div>
                        <br>
                        위 식에서 투영할 벡터 $\vec{v}$의 크기가 1이면 아래와 같이 단순하게 식이 정리된다. <br>
                        <br>
                        $\therefore \vec{v^{'}}=(\vec{u}·\vec{v})·\vec{v}$
                    </div>
                </div>
                <div class = "content2">
                    <h2>8장 삼각형: 물체를 구성하는 가장 작은 단위</h2>
                    <p>
                        · 8장 이전 까지는 눈에 보이지 않는 가상 공간을 만들고 이를 분석하고 측정하는데 필요한 수학에 대해 정리했다. <br>
                        · 8장 부터는 눈에 보이는 물체를 다루는 수학을 배울 것이다. 
                    </p>
                    <h3>세 점의 결합</h3>
                    <p>
                        · 앞서 학습한, <a href = "#two-verticies">🔗두 점의 결합</a>에서 두 점의 결합 결과는 선분, 반직선, 직선 중 하나가 되었다. <br>
                        · 그렇다면 세 점의 결합의 결과는 무엇일까? 아래에서 알아보자. <br>
                    </p>
                    <span class = "equation-h3">
                        아핀 결합식을 사용하여 세 점을 결합해보자. <br>
                        세 점 $P_{1}$, $P_{2}$, $P_{3}$이 있다고 하자, <br>
                        아핀 결합에 사용되는 스칼라는 그 합이 1이어야 함을 이전에 학습했다. <br>
                        따라서, 이 세 점의 아핀 결합은 아래와 같다. <br>
                        <br>
                        $P^{'}=s·P_{1}+t·P_{2}+(1-s-t)·P_{3}$<br>
                        <br>
                        두 점의 결합에서 선분이 만들어지는 조건과 같이 $s$, $t$의 범위를 [0, 1]로 고정하면<br>
                        세 점의 결합에서는 삼각형이 형성된다. <br>
                        이렇게 아핀 결합에서 사용되는 모든 스칼라 값을 [0, 1] 범위로 고정하여 결합하는 것을 <br>
                        <span class = "keyword">컨벡스 결합(convex combination)</span>이라고 한다. <br>
                        <br>
                        이는 아핀 결합식에 스칼라의 범위를 [0, 1]로 제한하는 조건을 추가하면 된다. 아래와 같다. <br>
                        <br>
                        $\sum_{n}^{i=1}c_{i}·P_{i} \space\space\space\space\space (s.t.\space\space\space \sum_{n}^{i=1}c_{i}=1,\space\space\space0\leq c_{i}\leq1)$<br>
                        <br>
                        이렇게 컨벡스 결합으로 생성한 영역을 <span class = "keyword">컨벡스 영역(convex region)</span>이라고 한다. <br>
                        4점을 컨벡스 결합할 경우 삼각뿔(tetrahedron)이 형성된다. <br>
                        <br>
                        컨벡스는 영어로 '볼록한'이라는 뜻인데, <span class = "emphasis">수학에서의 정의는 임의의 두 점을 연결한 선분이 항상 컨벡스 영역 내에 속함을 의미한다. </span><br>
                        이를 <span class = "keyword">컨벡스 성질</span>이라고 한다. <br>
                        즉, 컨벡스 결합으로 생성된 컨벡스 영역은 항상 컨벡스 성질을 만족한다. <br>
                        <br>
                        컨벡스의 반댓말은 '오목한'이라는 뜻인 컨케이브(concave)이다. <br>
                        컨케이브 영역은 임의의 두 점을 이은 선분이 영역 밖으로 벗어나는 경우가 존재한다. <br>
                        컨벡스 결합으로 만들어지는 1차원 선분, 2차원 삼각형, 3차원 삼각뿔 중, <span class = "emphasis">가상 공간의 물체를 표현하는데는 2차원 삼각형을 사용한다. </span> <br>
                        왜냐하면 삼각형은 2차원 물체를 표현할 수 있고, 3차원 물체도 표면만 표현하면 되므로, 결론적으로 두 경우 모두에 효과적이기 떄문이다. 
                    </span>
                    <h3>메시</h3>
                    <p>
                        · 물체를 구성하기 위해서는 삼각형을 사용하는데 <span class = "emphasis">삼각형은 2차원과 3차원을 가장 효과적으로 표현하게 해주므로</span> 이를 사용한다. <br>
                        · 점 3개를 사용하여 삼각형을 만들고, 삼각형 여러개를 모아 하나의 3차원 물체를 만든다. 이를 <span class = "keyword">메시(mesh)</span>라고 한다. <br>
                        · 이렇게 만들어진 3차원 물체의 점은 위치, 해당 지점의 생상, 방향등 다양한 부가 정보를 포함한다. 이를 <span class = "keyword">정점(vertex)</span>라고 한다. <br>
                        · 메시는 대게 수 많은 정점을 가진다. <br>
                        · 따라서, 이 정점을 빠르게 읽기 위해 메모리에 정점 정보를 일렬로 나열하여 배열로 저장하는데, 이 배열을 <span class = "keyword">정점 버퍼(vertex buffer)</span>라고 한다. <br>
                        · 하지만 정점 버퍼의 정보로는 어떤 정점이 모여서 삼각형을 이루는지 알 수 없다. <br>
                        · 따라서, 삼각형을 구성하는 정점의 인덱스를 배열을 따로 만드는데 이를 <span class = "keyword">인덱스 버퍼(index buffer)</span>라고 한다. <br>
                        · <span class = "emphasis">인덱스 버퍼는 '삼각형'의 수 (정점의 수 아님! ) 만큼 필요하다. </span>따라서 항상 3의 배수이다. <br>
                        · 정점 버퍼, 인덱스 버퍼 두 가지 배열 정보를 사용하여, 하나의 3차원 물체가 표현된다. <br>
                        (그림 *)<br>
                        · 정점을 연결하여 삼각형을 만들 때에는 삼각형들이 서로 접하는 선분의 경우 정점이 공유되는 부분이 있다. <br>
                        (그림 *)<br>
                        · 정점 배열과 인덱스 배열을 채운 후 각 점을 이어 삼각형으로 모두 만들어 외곽선만으로 메시를 표현하는 방법을 <span class = "keyword">와이어프레임(wireframe)이라고 한다. </span>
                    </p>
                    <h3>무게 중심 좌표</h3>
                    <h5>무게 중심 좌표의 계산</h5>
                    <h5>정점에 설정된 부가 정보의 활용</h5>
                    <h3>텍스처 매핑</h3>
                </div>
                <div class = "content2">
                    <h2>9장 게임 엔진: 콘텐츠를 만드는 기술</h2>
                    <h3>게임 엔진의 구성 요소</h3>
                    <h5>씬의 구조</h5>
                    <h5>로컬 공간과 로컬 축</h5>
                    <h3>게임 엔진의 워크플로우</h3>
                    <h5>CK소프트렌더러의 워크 플로우</h5>
                    <h5>렌더링 파이프라인</h5>
                    <h3>카메라 시스템</h3>
                    <h5>가상 공간의 카메라</h5>
                </div>
                <div class = "content2">
                    <h2>10장 3차원 공간: 입체 공간의 생성</h2>
                    <h3>3차원 공간의 설계</h3>
                    <h3>3차원 공간의 트랜스폼</h3>
                    <h5>오일러 각</h5>
                    <h5>회전행렬의 유도</h5>
                    <h5>3차원 모델링 행렬</h5>
                    <h3>카메라 공간</h3>
                    <h3>오일러 각의 특징</h3>
                    <h5>짐벌락 현상</h5>
                    <h5>회전 보간의 계산</h5>
                </div>
            </div>
            <div class = "console"></div>
    </section>
</body>
<script src = "https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
<script src = "../js/common.js" type = "module"></script>
</html>