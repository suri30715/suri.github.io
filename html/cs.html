<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>자료실</title>
    <link rel = "stylesheet" href = "../css/common.css">
    <link rel = "stylesheet" href = "../css/cs.css">
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
</head>
<body>
    <header></header>
    <section class = "layout">
        <div class = "sidebar"></div>
        <div class = "content"></div>
        <div class = "body">
            <div class = "rights">개인 공부용이며, 복사, 배포를 금지합니다. <br>
            검색은 ctrl + f!</div>
            <div class = "info">
                혼자 공부하는 컴퓨터 구조 + 운영체제(강민철 지음)를 개인적으로 정리한 내용입니다. 
            </div>
            <h1>CS study</h1>
            <div class = "content2">
                <h2>chapter01 컴퓨터 구조 시작하기</h2>
                <h3>컴퓨터 구조를 알아야 하는 이유</h3>
                <h4 id = "start">시작하기 전에</h4>
                <h4>문제 해결</h4>
                <p>
                    · 컴퓨터 구조를 잘 알면 코드의 문제 해결에 도움이 된다. 
                </p>
                <h4>성능, 용량, 비용</h4>
                <p>
                    · 예를 들어 서버 컴퓨터를 구매할 때 합리적으로 구매할 수 있다. 
                </p>
                <h3>컴퓨터 구조의 큰 그림</h3>
                <h4 id = "start">시작하기 전에</h4>
                <p>
                    · 컴퓨터 구조는 크게 2가지로 나뉜다. <br>
                    · 1. 컴퓨터가 이해하는 정보 <br>
                    · 2. 컴퓨터의 4가지 부품 
                </p>
                <h4>컴퓨터가 이해하는 정보</h4>
                <p>
                    · 컴퓨터는 0과 1로 표현된 정보만을 이해한다. 여기에는 2가지가 있다. <br>
                    · <span class = "keyword">데이터(data)</span>: 숫자, 문자, 이미지, 동영상과 같은 정적 정보<br>
                    · <span class = "keyword">명령어(instruction)</span>: 데이터를 사용하여 컴퓨터를 작동시키는 정보<br>
                    · 예: 숫자'1', '2'는 '데이터', '숫자1과 2를 더하라'는 '명령어'이다. <br>
                    · 예: 'cat.jpg'는 데이터, 'cat.jpg를 USB메모리에 저장하라'는 '명령어'이다. <br>
                    · 즉, 데이터는 명령어를 위해 존재하는 재료
                </p>
                <h4>컴퓨터의 4가지 핵심 부품</h4>
                <p>
                    · <span class = "keyword">중앙처리장치(CPU; Central Processing Unit; 이하 CPU)</span><br>
                    · <span class = "keyword">주기억장치(main memory; 이하 메모리(RAM))</span><br>
                    · <span class = "keyword">보조기억장치(scondary storage)</span><br>
                    · <span class = "keyword">입출력장치(input/output; I/O)</span>: 모니터, 키보드, 마우스 등
                    
                </p>
                (그림)
                <h5>메모리</h5>
                <p>
                    · 현재 실행되는 프로그램의 명령어와 데이터를 저장하는 부품<br>
                    · 즉, 프로그램이 실행되려면 반드시 메모리에 저장되어야한다. <br>
                    · 명령어와 데이터는 정돈되어 저장되어야하며, 값의 위치는 주소로 알 수 있다. <br>
                </p>
                (그림)
                <h5>cpu</h5>
                <p>
                    · 메모리에 저장된 명령어를 읽고, 해석하고, 실행하는 부품<br>
                    · '컴퓨터의 두뇌' 이다. <br>
                    · cpu 내부에는 여러 구성요소 중, 가장 중요한 3가지는 아래와 같다. <br>
                    · <span class = "keyword">산술논리연산장치(ALU; Arithmetic Logic Unit; 이하 ALU)</span>: 계산만을 위해 존재하는 부품, 쉽게 말해 계산기<br>
                    · <span class = "keyword">레지스터(register)</span>: 작은 임시 저장 부품<br>
                    · <span class = "keyword">제어장치(CU: Control Unit)</span>: 제어 신호(control signal: 컴퓨터 부품을 관리, 실행시키는 전기 신호)를 내보내고, 명령어를 해석하는 부품<br>
                    · 예: CPU가 메모리에 저장된 값을 읽고 싶으면 메모리를 향해 메모리 읽기 라는 제어신호를 보낸다. <br>
                    · 예: CPU가 메모리에 어떤 값을 저장하고 싶으면 메모리를 향헤 메모리 쓰기 라는 제어신호를 보낸다. <br>
                </p>
                <h5>보조기억장치</h5>
                <p>
                    · 메모리는 전원이 꺼지면 정보가 날아감, 전원이 꺼져도 필요한 정보를 저장하기 위한 부품
                </p>
                <h5>입출력장치</h5>
                <p>
                    · 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환하는 부품 <br>
                    · 키보드, 마우스 등...
                </p>
                <h5>메인보드와 시스템 버스</h5>
                <p>
                    · <span class = "keyword">메인 보드(main board(mother board))</span>: 앞서 설명한 부품들 모두를 연결하는 판<br>
                    · <span class = "keyword">버스(bus)</span>: 메인 보드에 연결된 부품들끼리는 정보를 주고받는 통로<br>
                    · <span class = "keyword">시스템 버스(system bus)</span>: 버스 중 4가지 핵심 부품을 연결하는 가장 중요한 버스<br>
                    · 시스템 버스는 3가지로 구성되어있다. <br>
                    · <span class = "keyword">주소 버스(address bus)</span>: 주소를 주고 받는 통로<br>
                    · <span class = "keyword">데이터 버스(data bus)</span>: 명령어와 데이터를 주고 받는 통로<br>
                    · <span class = "keyword">제어 버스(control bus)</span>: 제어 신호를 주고 받는 통로<br>
                </p>
            </div>
            <div class = "content2">
                <h2>chapter02 데이터</h2>
                <h3>0과 1로 숫자를 표현하는 방법</h3>
                <h4 id = "start">시작하기 전에</h4>
                <p>
                    · 컴퓨터는 0과 1만으로 구성된 데이터와 명령어만을 이해할 수 있다. <br>
                    · 그렇다면 '3+4'와 같은 것은 어떻게 이해할까? 
                </p>
                <h4>정보 단위</h4>
                <p>
                    · <span class = "keyword">비트(bit)</span>: 0과 1 둘 중 하나를 나타낼 수 있는 단위 <br>
                    · 1비트는 0 혹은 1 중 1개를 나타 낼 수 있으므로, 총 2가지 정보를 나타낼 수 있다. <br>
                    · 즉, n개의 비트는 $2^{n}$개의 정보를 나타낼 수 있다. <br>
                    · 1바이트(8비트) > 1킬로바이트(1000바이트) > 1메가바이트(1000킬로바이트) > 1기가바이트(1000메가바이트) > 1테라바이트 (1000기가바이트)<br>
                </p>
                <h4>이진법</h4>
                <p>
                    · 수를 0과 1만으로 모든 수를 표현하는 방법이다. <br>
                    · 일반생활에서 사용하는 십진법은 0~9의 숫자로 모든 수를 표현하는 방법이다. <br>
                    · 십진법으로 숫자를 표현할 때, 자리수가 10이 되는 시점에서 0으로 바꾸고 다음 자리수를 1 올려준다. 
                    · 이진법으로 숫자를 표현할 때는, 이와 비슷하게 자리수가 2가 되는 시점에서 0으로 바꾸고 다음 자리수를 1올려준다. <br>
                    · <span class = "keyword">십진수</span>: 십진법으로 표현한 수 <br>
                    · <span class = "keyword">이진수</span>: 이진법으로 표현한 수 <br>
                    · <span class = "emphasis">수학적 이진수 표기</span>: 아래첨자(2)를 뒤에 붙임(예: $10000_{(2)}$ (숫자 8의 수학적 이진수 표기))<br>
                    · <span class = "emphasis">코드상의 이진수 표기</span>: 0b를 앞에 붙임 (예: 0b10000(숫자 8의 코드상 이진수 표기))
                </p>
                <h5>이진수의 음수 표현</h5>
                <p>
                    · <span class = "keyword">2의 보수(two's complement): 0과 1만으로 음수를 표현하는 방법</span>
                    · 컴퓨터는 0과 1만 이해하므로 음수 부호를 알지 못함 <br>
                    · 2의 보수의 사전적 의미는 '어떤 수를 그보다 큰 $2^{n}$에서 뺀 값'을 의미 <br>
                    · 사전적 의미로 이해하기보다, '이진수의 0은 1, 1은 0으로 뒤집고 거기에 1을 더한 값'이라고 생각하면됨. <br>
                    · 하지만 이렇게 해도 이진수이므로 어쨌는 다른 이진수이므로 음수양수 구분이 불가하다. <br>
                    · <span class = "keyword">플래그(flag)</span>: 어떤 값에 대한 부가 정보를 의미<br>
                    · 2의 보수 표현으로된 이진수에 음수 플래그를 부여하여 CPU가 알 수 있도록 한다. 
                </p>
                <h5 id = "stop">2의 보수 표현의 한계</h5>
                <p>
                    · 2의 보수 표현은 완벽한 방식은 아니다. <br>
                    · $2^{n}$의 이진수에 2의 보수를 취하면 음수를 구할 수 없다. 
                </p>
                <h4>십육진법</h4>
                <table class = "h4-table">
                    <tr>
                        <td>십진수</td>
                        <td>0</td>
                        <td>1</td>
                        <td>2</td>
                        <td>3</td>
                        <td>4</td>
                        <td>5</td>
                        <td>6</td>
                        <td>7</td>
                        <td>8</td>
                        <td>9</td>
                        <td>10</td>
                        <td>11</td>
                        <td>12</td>
                        <td>13</td>
                        <td>14</td>
                        <td>15</td>
                        <td>16</td>
                        <td>17</td>
                    </tr>
                    <tr>
                        <td>십육진수</td>
                        <td>0</td>
                        <td>1</td>
                        <td>2</td>
                        <td>3</td>
                        <td>4</td>
                        <td>5</td>
                        <td>6</td>
                        <td>7</td>
                        <td>8</td>
                        <td>9</td>
                        <td>A</td>
                        <td>B</td>
                        <td>C</td>
                        <td>D</td>
                        <td>E</td>
                        <td>F</td>
                        <td>10</td>
                        <td>11</td>
                    </tr>
                </table>
                <p>
                    · 자리수가 15를 넘어가는 시점에 자리 올림을 하는 표현 방식 <br>
                    · 이진법은 0과 1로 모든 숫자를 표현하는데 이는 숫자의 길이가 너무 길어진다는 단점이 있다. <br>
                    · 십육진법은 한자리수가 16 종류의 정보를 표현 가능하므로 이진수에 비해 작은 자릿수로 더 많은 정보를 표현할 수 있다. <br>
                    · 따라서, 길이를 줄이기 위해 데이터 표현 시 십육진법도 자주 쓴다. <br>
                    · <span class = "emphasis">수학적 십육진수 표기</span>: 아래첨자(16)를 뒤에 붙임(예: $15_{(16)}$ (숫자 21의 수학적 이진수 표기))<br>
                    · <span class = "emphasis">코드상의 십육진수 표기</span>: 0x를 앞에 붙임 (예: 0x15(숫자 21의 코드상 이진수 표기))
                </p>
                <h5 id = "stop">십육진수 A~F를 쉽게 이해하는 방법</h5>
                <p>
                    · 주먹을 쥐었을 때(손가락을 안 폈을 때) A: 1<span class = "emphasis">0(손가락 0)</span>손가락을 하나씩 피면서 알파벳 순(위 표랑 비교해서 이해하기)
                </p>
                <h5>십육진수를 이진수로 변환하기</h5>
                <p>
                    · <span class = "emphasis">십육진수를 이진수로 변환에 필요한 비트</span>: $2^{n}$이므로 n = 4 즉 4비트가 필요 <br>
                    · 십육진수 숫자 하나는 16개의 정보를 담을 수 있으므로 이진수로 변환하라면 $2^{n}$이므로 $2^{4} = 16 $, $n = 4$ 즉 4비트가 필요 <br>
                    · <span class = "emphasis">가장 간편한 방법중 하나</span>: 16진수 자리수 각각을 이진수로 변환하여 이어붙이는 방법. <br>
                </p>
                <h5>이진수를 십육진수로 변환하기</h5>
                <p>
                    · 이진수 숫자를 4개 씩 끊어서 하나의 16진수로 변환후 이어 붙이면 됨
                </p>
                <h3>0과 1로 문자를 표현하는 방법</h3>
                <h4 id = "start">시작하기 전에</h4>
                <p>
                    · 컴퓨터는 0과 1만 이해한다고 했는데 어떻게 문자를 이해하고 모니터에 출력할까? 
                </p>
                <h4>문자 집합과 인코딩</h4>
                <p>
                    · <span class = "keyword">문자 집합(character set)</span>: 컴퓨터가 인식하고 표현할 수 있는 문자들을 모아둔 집합<br>
                    · <span class = "keyword">인코딩(character incoding; 문자 인코딩)</span>: 문자를 컴퓨터가 이해할 수 있는 0과 1로 변환하는 과정<br>
                    · <span class = "keyword">디코딩(character decoding; 문자 디코딩)</span>: 0과 1로 변환된 문자를 사람이 이해할 수 있는 문자로 변환하는 과정<br>
                    · 문자 집합에 속하지 않은 문자는 컴퓨터가 이해할 수 없음. <br>
                    · 문자 집합에 속하더라도 인코딩을 하지 않으면 컴퓨터는 이해할 수 없음. <br>
                    · 지금부터 다양한 문자 집합과 인코딩 방법에 대해 알아보자. 
                </p>
                <h4>아스키 코드</h4>
                <p>
                    · <span class = "keyword">아스키(ASCII; American Standard Code for Information Interchange)</span>: 영어 알파벳, 아라비아 숫자, 일부 특수문자가 포함된 문자 집합 <br>
                    · <span class = "keyword">아스키 코드</span>: 아스키의 문자들 각각에 대응된 고유한 수, 이수를 이진수로 나타내는 것이 아스키 문자를 아스키 코드로 인코딩하는 것이라고 한다. <br>
                    · <span class = "keyword">코드 포인트(code point)</span>: 아스키 코드 처럼 문자 집합의 문자들 각각에 대응되는 고유 값을 의미하는 단어. <br>
                    · 아스키 문자 집합에 속한 문자는 각각 7비트로 표현됨. (사실 8비트이나 1비트는 패리티 비트; 오류 검출을 위해 사용되는 비트) <br>
                    · 즉, 아스키 문자세트는 총 $2^{7} = 128$개의 문자를 가짐.  <br>
                    · 아스키 문자세트는 영문자와 아스키 문자 세트에 포함된 특수문자만을 표현할 수 있다. <br>
                    · 즉, 영문자이외의 문자(이를테면 한글), 문자 세트 이외의 특수문자는 표현할 수 없다. <br>
                    · 아스키 코드에 1비트를 추가한 <span class = "keyword">확장 아스키(extended ASCII)</span>도 있지만, 이 또한 표현 가능 문자가 256개여서 턱없이 부족했다. <br>
                    · 따라서, 한국을 포함 영어권 외의 나라들은 자신들의 문자를 0과 1로 표현할 수 있는 과유 문자 집합과 인코딩 방식을 개발했다. <br>
                </p>
                <h4>EUC-KR</h4>
                <p>
                    · <span class = "keyword">완성형 인코딩</span>: 초, 중, 종성이 있는 한글을 모두 합친 것으로 글자 코드를 만드는 것 <br>
                    · <span class = "keyword">조합형 인코딩</span>: 초, 중, 종성 각각에 코드를 부여하여 조합으로 하나의 글자 코드를 만드는 것<br> 
                    · <span class = "keyword">EUC-KR</span>: KS X 1001, KS X 1003이라는 문자 집합을 기반으로 하는 대표적인 완성형 인코딩 방식 초,중,종성이 결합된 하나의 글자에 2byte 크기 코드 부여<br>
                    · EUC-KR은 하나의 문자에 2바이트 코드가 부여되므로 16진수로 표현 가능 <br>
                    · EUC-KR 인코딩 방식은 2,350개 한글 문자를 표현가능하지만 여전히 표현하지 못하는 한글 문자도 있음(예: 쀍, 쀍, 믜) <br>
                    · 이 경우 문제가 생길 수 있는데 이 인코딩 방식을 사용하는 웹사이트의 글자가 깨진다거나 할 수 있음. <br>
                    · 즉 EUC-KR도 한글 전체를 표현할 수는 없음. 
                </p>
                <h4>유니코드와 UTF-8</h4>
                <p>
                    · <span class = "keyword">유니코드(Unicode)</span>: EUC-KR보다 훨씬 다양한 한글을 포함, 대부분 나라의 문자, 특수문자, 화살표, 이모티콘 까지도 코드로 표현함. <br>
                    · <span class = "keyword">UTF-8</span>: 유니코드에 부여된 값을 다양한 방법으로 인코딩하는 방식 중 하나 <br>
                    · EUC-KR의 경우 각 문자에 부여된 코드 값을 그대로 인코딩 값으로 삼았다면, 유니코드는 다양한 방식으로 인코딩한다. <br>
                    · UTF-8, UTF-16, UTF-32 등이 있다. 유니코드 문자 집합의 문자들 각각에 부여된 코드 값을 인코딩하는 각기 다른 방식이다. 
                </p>
            </div>
            <div class = "content2">
                <h2>chapter03 명령어</h2>
                <h3>소스 코드와 명령어</h3>
                <h4>고급 언어와 저급 언어</h4>
                <h4>컴파일 언어와 인터프리터 언어</h4>
                <h5>컴파일 언어</h5>
                <h5>인터프리터 언어</h5>
                <h5 id = "more">목적파일 vs 실행 파일</h5>
                <h3>명령어의 구조</h3>
                <h4>연산 코드와 오퍼랜드</h4>
                <h5>오퍼랜드</h5>
                <h5>연산 코드</h5>
                <h4>주소 지정 방식</h4>
                <h5>즉시 주소 지정 방식</h5>
                <h5>직접 주소 지정 방식</h5>
                <h5>간접 주소 지정 방식</h5>
                <h5>레지스터 주소 지정 방식</h5>
                <h5>레지스터 간접 주소 지정 방식</h5>
                <h5 id = "more">스택과 큐</h5>
            </div>
            <div class = "content2">
                <h2>chapter04 CPU의 작동 원리</h2>
                <h3>ALU와 제어장치</h3>
                <h4>ALU</h4>
                <h4>제어장치</h4>
                <h5>첫째, 제어 장치는 클럭 신호를 받아들입니다. </h5>
                <h5>둘째, 제어장치는 '해석해야 할 명령어'를 받아들입니다. </h5>
                <h5>셋째, 제어장치는 플래그 레지스터 속 플래그 값을 받아들입니다. </h5>
                <h5>넷째, 제어장치는 시스템 버스, 그중에서 제어 버스로 전달된 제어 신호를 받아들입니다. </h5>
                <h3>레지스터</h3>
                <h4>반드시 알아야 할 레지스터</h4>
                <h5>프로그램 카운터</h5>
                <h5>명령어 레지스터</h5>
                <h5>메모리 주소 레지스터</h5>
                <h5>메모리 버퍼 레지스터</h5>
                <h5 id = "stop">순차적인 실행 흐름이 끊기는 경우</h5>
                <h5>범용 레지스터</h5>
                <h5>플래그 레지스터</h5>
                <h4>특정 레지스터를 이용한 주소 지정 방식(1): 스택 주소 지정 방식</h4>
                <h4>특정 레지스터를 이용한 주소 지정 방식(2): 변위 주소 지정 방식</h4>
                <h5>상재 주소 지정 방식</h5>
                <h5>베이스 레지스터 주소 지정 방식</h5>
                <h5 id = "more">상용화된 CPU속 레지스터 및 주소 지정 방식</h5>
                <h3>명령어 사이클과 인터럽트</h3>
                <h4>명령어 사이클</h4>
                <h4>인터럽트</h4>
                <h5>하드웨어 인터럽트</h5>
                <h5>하드웨어 인터럽트 처리 순서</h5>
                <h5 id = more>예외의 종류</h5>
            </div>
            <div class = "content2">
                <h2>chapter05 CPU 성능 향상 기법</h2>
                <h3>빠른 CPU를 위한 설계 기법</h3>
                <h4 id = "start"></h4>
                <h4>클럭</h4>
                <h4 id = "stop">클럭 속도는 일정하지 않다. </h4>
                <h3>코어와 멀티 코어</h3>
                <h3>스레드와 멀티스레드</h3>
                <h4>하드웨어적 스레드</h4>
                <h4>소프트웨어적 스레드</h4>
                <h4>멀티스레드 프로세서</h4>
                <h3>명령어 병렬 처리 기법</h3>
                <h4 id = "start"></h4>
                <h4>명령어 파이프라인</h4>
                <h5>데이터 위험</h5>
                <h5>제어 위험</h5>
                <h5>구조적 위험</h5>
                <h4>슈퍼스칼라</h4>
                <h4>비순차적 명령어 처리</h4>
                <h3>CISC와 RISC</h3>
                <h4 id = "start"></h4>
                <h4>명령어 집합</h4>
                <h4>CISC</h4>
                <h4>RISC</h4>
            </div>
            <div class = "content2">
                <h2>chapter06 메모리와 캐시 메모리</h2>
                <h3>RAM의 특징과 종류</h3>
                <h4 id = "start"></h4>
                <h4>RAM의 특징</h4>
                <h4>RAM의 용량과 성능</h4>
                <h4>RAM의 종류</h4>
                <h5>DRAM</h5>
                <h5>SRAM</h5>
                <h5>DDR SDRAM</h5>
                <h3>메모리의 주소 공간</h3>
                <h4 id = "start"></h4>
                <h4>물리 주소와 논리 주소</h4>
                <h4>메모리 보호 기법</h4>
                <h3>캐시 메모리</h3>
                <h4 id = "start"></h4>
                <h4>저장 장치 계층 구조</h4>
                <h4>캐시 메모리</h4>
                <h4 id = "stop">분리형 캐시</h4>
                <h4>참조 지역성 원리</h4>
                <h5>첫째, '최근에 접근했던 메모리 공간에 다시 접근하려는 경향'은 무엇일까요? </h5>
                <h5>둘째, '접근한 메모리 공간 근처를 접근하려는 경향'은 무엇일까요? </h5>
            </div>
            <div class = "content2">
                <h2>chapter07 보조기억장치</h2>
                <h3>다양한 보조기억장치</h3>
                <h4 id = "start"></h4>
                <h4>하드 디스크</h4>
                <h5 id = "stop">다중 헤드 디스크와 고정 헤드 디스크</h5>
                <h4>플래시 메모리</h4>
                <h5 id = "stop">두 종류의 플래시 메모리</h5>
                <h5 id = "stop">플래시 메모리도 수명이 있나요? </h5>
                <h5>SLC 타입</h6>
                <h5>MLC 타입</h6>
                <h5>TLC 타입</h6>
                <h3>RAID의 정의와 종류</h3>
                <h4 id = start></h4>
                <h4>RAID의 정의</h4>
                <h4>RAID의 종류</h4>
                <h5>RAID 0</h5>
                <h5>RAID 1</h5>
                <h5>RAID 4</h5>
                <h5 id = "stop">오류를 검출하는 패리티 비트</h5>
                <h5>RAID 5</h5>
                <h5>RAID 6</h5>
            </div>
        </div>
    </section>
</body>
<script src = "https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
<script src = "../js/common.js" type = "module"></script>
</html>