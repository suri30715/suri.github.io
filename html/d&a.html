<!-- 출처 -->
<!-- 책: C언어로 쉽게 풀어쓴 자료구조 - 천인국, 공용해 하상호 지음 -->
<!-- https://jin-network.tistory.com/127 -->
<!-- https://www.hanbit.co.kr/media/channel/view.html?cms_code=CMS2832062046 -->
<!-- https://bnzn2426.tistory.com/115 -->
<!-- https://lizable.github.io/datastructure/Introductions-to-data-structure/#description -->
<!-- https://naeunbi698.tistory.com/139 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>자료실</title>
    <link rel = "stylesheet" href = "../css/common.css">
</head>
<body>
    <header></header>
    <section class = "layout">
        <div class = "sidebar"></div>
        <div class = "content"></div>
        <div class = "body">
            <div class = "rights">
                개인 공부용이며, 복사, 배포를 금지합니다. <br>
                검색은 ctrl + f!
            </div>
            <div class = "info">
                C언어로 쉽게 풀어쓴 자료구조(천인국, 공용해 하상호 지음)를 개인적으로 정리한 내용입니다. 
            </div>
            <h1>1. 자료구조 & 알고리즘</h1>
            <div class = "content1">
                <h2>1.1 자료구조란? </h2>
                <p> · 프로그램에서 자료들을 정리하여 보관하기위한 여러 구조들이다. <br>
                    · 자료구조는 알고리즘을 구현하기 위해 사용되는 도구라고 할 수 있다. <br>
                    · 효율적인 알고리즘을 위해 문제에 적당한 자료구조를 알고리즘에 적용해야한다. <br>
                    · 본문에서는 필수 자료구조 8가지(배열, 스택, 큐, 링크드 리스트, 트리, 힙, 그래프, 해시 테이블)에 대해서 알아보자. </p>
                </p>
                <h2>1.2 선형 자료구조 (linear datastructure)</h2>
                <div class = "content2">
                <h3>1.2.1 배열 (array)</h3>
                    <p>· 배열은 거의 모든 프로그래밍 언어에 기본적으로 제공되는 자료형이다. <br>
                       · 배열은 같은 데이터형의 데이터를 여러 개 저장할 때 사용한다. <br>
                       · 배열은 연속으로 이어진 메모리 공간이 할당된다. <br> 
                       &nbsp;&nbsp;&nbsp;따라서, 인덱스를 이용하여 쉽게 접근이 가능하다. </p>
                       <h5>- 정적 배열 (static array)</h5>
                       <h5>- 동적 배열 (dynamic array)</h5>
                    <h4>1.2.1.1 배열의 활용</h4>
                    <h5>- 다항식의 표현</h5>
                    <h6>1. 모든 차수의 계수값을 배열에 저장하는 방법</h6>
                        <p>· 이 방법은 간단하지만 다항식의 최고차항이 100처럼 크고 다른 차수가 없을 경우 <br>
                            &nbsp;&nbsp;&nbsp;메모리 낭비, 하지만 연산 함수 구현은 2. 보다 간단. </p>
                    <h6>2. 공간 절약을 위해 0이 아닌 항만을 저장하는 방법</h6>
                    <p>· 구조체형 배열을 이용하는 방법 이 방법은 메모리는 1.보다 절약되지만 연산 함수 구현이 까다로움 <br></p>
                    <h5>- 희소행렬의 표현</h5>
                    <p>· 행렬을 프로그램에서 표현하는 것은 매우 중요 <br>
                        · 행렬은 일반적으로 2차원 배열로 표현</p>
                </div>
                <div class = "content2">
                    <h3>1.2.2 스택 (stack)</h3>
                    <p> · 스택은 컴퓨터에서 정말 정말 많이 사용되는 자료 구조이다. <br>
                        · LIFO 구조이다.  <br>
                        · 배열은 같은 데이터형의 데이터를 여러 개 저장할 때 사용한다. <br>
                        · 배열은 연속으로 이어진 메모리 공간이 할당된다. <br> 
                        &nbsp;&nbsp;&nbsp;따라서, 인덱스를 이용하여 쉽게 접근이 가능하다. </p>
                        <h4>1.2.2.1 스택의 활용</h4>
                        <h5>- 시스템 스택을 이용한 함수 호출</h5>
                        <p> · 컴퓨터안에서는 수 많은 함수 호출이 이루어지는데 함수는 실행이 끝나면 자신을 호출한 함수로 돌아가야한다. <br>
                            · 이 때 스택이 사용되며, 스택의 메모리 블록에는 복귀할 함수의 주소를 저장한다. <br>
                            · 함수가 실행 되는 순간 스택에 해당 함수 주소가 저장되고, <br>
                            &nbsp;&nbsp;&nbsp;리턴 되는 순간 해당 함수 주소가 삭제되고 다음 메모리블록에 저장된 함수의 주소로 이동한다. <br>
                            · 여러 함수나 재귀 함수나 시스템 스택에 저장되므로 작동 방식은 똑같다. 
                        </p>
                        <h5>- 뒤로가기 (웹 페이지 등...)</h5>
                        <h5>- 미로 문제 (maze solving problem)</h5>
                    </div>
                <div class = "content2">
                    <h3>1.2.3 큐 (queue)</h3>
                    <h4>1.2.3.1 큐의 종류</h4>
                    <h5>- 선형 큐</h5>
                    <h5>- 원형 큐</h5>
                    <h5>- 덱 (double-ended-queue)</h5>
                    <h4>1.2.3.1 큐의 활용</h4>
                    <h4></h4>
                </div>
                <div class = "content2">
                    <h3>1.2.4 연결 리스트 (linked-list)</h3>
                    <h4>1.2.4.1 연결리스트의 종류</h4>
                    <h5>- 단순 연결 리스트</h5>
                    <h5>- 원형 연결 리스트</h5>
                    <h5>- 이중 연결 리스트</h5>
                    <h4>1.2.4.2 연결 리스트의 활용</h4>
                </div>
                <h2>1.3 비선형 자료구조 (non-linear datastructure)</h2>
                <div class = "content2">
                    <h3>1.3.1 트리 (tree)</h3>
                    <h4>1.3.1.1 트리의 종류</h4>
                    <h5>- 포화 이진 트리(full binary tree)</h5>
                    <h5>- 완전 이진 트리(complete binary tree)</h5>
                    <h6>&nbsp;&nbsp;&nbsp; 힙 (heap)</h6>
                           <p>· 힙(heap)은 영어로 더미라는 뜻, 완전 이진 트리의 형태로 만들어진 자료구조이다. <br>
                            · 자료구조인 우선순위 큐를 구현할 때 그리고 <br>
                            &nbsp;&nbsp;&nbsp;알고리즘인 힙 정렬을 구현할 때 사용된다.</p>
                    <h5>- 기타 이진 트리</h5>
                    <h5>- 스레드 이진 트리</h5>
                    <h5>- 이진 탐색 트리</h5>
                    <h6>&nbsp;&nbsp;&nbsp; 해시 테이블 (hash-table)</h6>
                    <p>· 이진 탐색 트리에서 데이터의 키로 1차원 배열의 인덱스를 사용하는 것 (?)<br>
                       · 이진 탐색트리의 최대 성능 O(log n) 이 O(1)이 될 수 있음 (?) </p>
                    <h4>1.3.1.2 트리의 활용</h4>
                </div>
                <div class = "content2">
                    <h3>1.3.4 그래프 (graph)</h3>
                </div>
                <div class = "content2">
                    <h3>1.3.5 해시테이블 (hash table)</h3>
                </div>
                <h2>1.4 그 외 자료구조</h2>
                <div class = "content2">
                    <h3>1.4.1 우선순위 큐 (priority queue)</h3>
                    <p> · 일반적인 큐는 FIFO로 데이터가 입출력되지만, <br>
                        &nbsp;&nbsp;&nbsp;우선순위 큐는 데이터에 우선순위가 부여되며, 우선순위가 높은 데이터가 먼저 나간다. </p>
                    <h4>1.4.1.1 우선 순위 큐의 구현</h4>
                    <h5>- 배열을 사용</h5>
                    <h5>- 연결리스트를 사용</h5>
                    <h5>- 힙을 사용</h5>

                    <h4>1.4.1.2 우선 순위 큐의 활용</h4>
                </div>
            </div>
            <div class = "content1">
                <h2>2.1 알고리즘이란?</h2>
                <p>· 컴퓨터로 어떤 문제를 풀기 위한 단계적 절차이다. </p>
                <h5>- 알고리즘 성능 분석</h5>
                <p>· 수행 시간이 적고, 컴퓨터 자원(메모리 등)을 적게 사용할 수록 효율적인 알고리즘이라 할 수 있다. <br>
                </p>
                <h5>- 알고리즘 복잡도 분석(complexity analysis)</h5>
                <p>· 어떤 알고리즘을 일일히 직접 구현하지 않고 효율성을 알아보기위한 방법이다. <br>
                   · 알고리즘 복잡도 분석은 특정 알고리즘을 직접 구현하지 않고도 모든 입력을 고려하는 방법이고, <br>
                   &nbsp;&nbsp;&nbsp;실행 하드웨어, 소프트웨어 환경과 관계없이 효율성을 측정할 수 있다. </p>
                <h5>- 시간 복잡도 함수</h5>
                <p>· 알고리즘 수행시간 분석은 시간 복잡도 (time complexity)라 하고, <br>
                &nbsp;&nbsp;&nbsp;알고리즘이 사용하는 메모리 분석을 공간 복잡도(space complexity)라 한다. <br>
                   · 알고리즘 복잡도를 이야기할 때는 시간 복잡도를 말한다. 이유는 대게 수행 시간에 관심을 가지기 때문이다. <br>
                   · 시간 복잡도 분석은 알고리즘의 연산의 수행 횟수를 사용한다. <br>
                   &nbsp;&nbsp;&nbsp;연산의 수를 입력의 개수 n의 함수로 나타낸 것을 시간 복잡도 함수라 한다. (T(n))</p>
                <h5>- 빅 오 표기법</h5>
                <p>· T(n) = n^2 + n + 1이라는 시간 복잡도 함수가 있다고 하면, <br>
                    &nbsp;&nbsp;&nbsp;n=1,000일 때 두번째항 n은 값의 전체의 약 0.1% 밖에 되지 않는다. <br>
                    · 따라서 보통 시간 복잡도 함수에서 차수가 가장 큰 항만 고려하면 충분하다. 이때 계수도 일반적으로 무시하고 차수만 고려한다. <br>
                    · 시간 복잡도 함수에서 불필요한 항을 제거하여, <br>
                    &nbsp;&nbsp;&nbsp;알고리즘 분석을 쉽게 하도록 시간 복잡도 함수를 표시하는 것을 빅오 표기법이라고한다. </p>
                    <h2>2.2 알고리즘의 종류</h2>
                    <div class = "content2">
                        <h3>2.2.1 탐색 알고리즘 (search)</h3>
                        <h5>- 선형 탐색(linear search)</h5>
                        <h5>- 이진 탐색(binary search)</h5>
                        <h5>- 순차 탐색(binary search)</h5>
                        <h5>- 해시 탐색(binary search)</h5>
                    </div>
                    <div class = "content2">
                        <h3>2.2.2 재귀(순환) (recursion) </h3>
                        <p> · 함수의 재귀 호출 즉, 재귀(순환) 알고리즘은 기본적으로 반복문(while, for)의 사용과 같으나, <br>
                        상황에 따라 알맞은 알고리즘을 사용해야 효율이 좋다. </p>
                        <h4>2.2.2.1 재귀의 활용</h4>
                        <h5>- 재귀 함수의 호출 스택</h5>
                        <p> · 프로그래밍 언어에서 하나의 함수가 자기 자신을 다시 호출하는 것은 <br>
                        다른 함수를 호출하는것과 동일하다. </p>
                        <h5>- 팩토리얼의 계산</h5>
                        <p> · 재귀 함수를 이용하여 팩토리얼 계산을 할 수 있다. </p>
                        <h5>- 거듭제곱 값의 계산</h5>
                        <p> · 수의 거듭제곱은 반복문, 재귀 함수 두 가지 형태 모두 사용가능하지만<br>
                        거듭 제곱 횟수가 증가할 수록 반복문의 경우가 시간이 훨씬 많이 든다. </p>
                        <h5>- 피보나치 수열의 계산</h5>
                        <p> · 피보나치 수열은 앞의 두 개의 숫자를 더하여 뒤의 숫자를 만드는 수열이다. </p>
                        <h5>- 하노이 탑 문제의 해결 (The Tower of Hanoi)</h5>
                        <p> · 하노이탑 문제이다. 직접 게임을 해보고 하노이탑 알고리즘 구현을 이해해보자. <br>
                        <a href = https://vidkidz.tistory.com/649  target="_blank" rel="noopener noreferrer">🔗 하노이탑 플래시 게임</a><br>
                            · 하노이 탑에서 원판의 최소 이동 횟수는 2^n - 1회 이다. <br>
                            · 결국 맨 밑의 원판을 최종 막대로 옮기는 형태이다. </p>
                        <h5>- 최대공약수(GDC) 구하기</h5>
                    </div>
                    <div class = "content2">
                        <h3>2.2.3정렬 (sort)</h3>
                        <h5>- 버블 정렬 (bubble sort)</h5>
                        <p>· 정렬되는 모습이 마치 바다 속에서 거품이 올라오는 모양이라서 붙여진 이름이다. </p>
                        <h5>- 선택 정렬 (selection sort)</h5>
                        <h5>- 삽입 정렬 (insertion sort)</h5>
                        <h5>- 힙 정렬 (heap sort)</h5>
                        <h5>- 병합 정렬 (merge sort)</h5>
                        <h5>- 퀵 정렬 (quick sort)</h5>
                    </div>
            </div>
        </div>
    </section>
</body>
<script src = "https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
<script src = "../js/common.js" type = "module"></script>
</html>